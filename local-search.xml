<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>TLS/SSL如何保证HTTPS协议的安全</title>
    <link href="/2022/04/15/TLS-SSL%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81HTTPS%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%AE%89%E5%85%A8/"/>
    <url>/2022/04/15/TLS-SSL%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81HTTPS%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%AE%89%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="TLS-SSL如何保证HTTPS协议的安全"><a href="#TLS-SSL如何保证HTTPS协议的安全" class="headerlink" title="TLS/SSL如何保证HTTPS协议的安全"></a>TLS/SSL如何保证HTTPS协议的安全</h1><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>  1999年6月，万维网协会(W3C)和互联网工程任务组（IETF）共同发布了RFC2616，这份标准规范化了接下来20年里十分重要的一个协议–HTTP。HTTP协议是一个客户端和服务端之间进行请求和应答的标准，能够让客户端使用标准的方式从服务器内获取各种资源，如HTML，数字图像等等。</p><p>  虽然HTTP得到了广泛的使用，但是HTTP的安全行性难以得到保证。攻击者可以通过监听和中间人攻击等手段获取网站账户和敏感信息。为了解决这一问题，1994年网景公司首次提出了HTTPS协议，该协议可在使用适当的加密包以及服务器证书可被验证和信任时，对窃听和中间人攻击提供合理的防护。</p><p>  HTTPS协议的原理是在HTTP与传输层（如TCP）之间建立一条可靠安全套接层(SSL)。该层的主要任务是提供私密性和身份认证。后来IETF在SSLv3的基础上做了一定的修改，形成了TLS，即安全传输协议。安全的传输协议建立在密文传输的基础上，下面从加密和及身份认证技术两个方面来叙述TLS/SSL为HTTP提供的防护措施。</p><h3 id="加密和身份认证"><a href="#加密和身份认证" class="headerlink" title="加密和身份认证"></a>加密和身份认证</h3><h4 id="对称加密和非对称加密"><a href="#对称加密和非对称加密" class="headerlink" title="对称加密和非对称加密"></a>对称加密和非对称加密</h4><p>从密钥划分的角度上来说，加密分为对称加密和非对称加密两种。非对称加密的加密和解密采用的是同一串密钥，用户使用同一个私钥可以同时加密和解密明文和密文，常见的对称加密算法有AES和DES等等。与之不同的非对称加密的</p><p>密钥分为公钥和私钥两种，使用公钥加密的密文只有使用私钥才能解密，反之亦然。常见的非对称加密算法有RSA等等。</p><p>相对非对称加密来说，对称加密的效率要高得多，但是由于难以对密钥进行分发和管理，因此对称加密的安全性更低。而非对称加密恰恰相反，发布者只需发布公钥，别人即可使用公钥加密明文并将密文发送给发布者，发布者可以用私钥对密文进行解密。整个流程中私钥完全不会泄露，这也体现了非对称加密更高的安全性。但是非对称加密的加解密的时间长，速度慢，只适合加解密少量数据。</p><p>TLS/SSL协议结合了这两者的优点：使用对称加密来加解密实际数据，而使用非堆成加密来加密对称密钥。这样既能保证加解密的速度，又能解决密钥的分发问题。</p><h4 id="身份认证和数字证书"><a href="#身份认证和数字证书" class="headerlink" title="身份认证和数字证书"></a>身份认证和数字证书</h4><p>上述非对称加密的公私钥体系虽然能保证信息的私密性，但是无法做到身份认证。考虑这样一种情况：存在一个第三者发送了假的公钥给客户端，然后用这个假公钥对应的私钥给客户端发送信息以欺骗客户端。此时的客户端完全不知道与自己通信的服务端是假冒的。这个场景下的关键问题是，服务器如何证明自己的身份，数字证书的存在解决了这一问题。</p><p>所谓的数字证书，就是首先要确立一个足够信任的第三方C，C使用自己的私钥对服务器S提供的公钥做加密，然后服务器再将加密后的公钥发送给客户端，客户端使用C提供的公钥对加密后的服务器公钥做解密，如果能正常解密就说明第三方C证明了服务器S的身份，这样就解决了服务器的身份认证问题。该过程的流程图如图所示：</p><p><img src="https://tvax4.sinaimg.cn/mw690/007bwgzIgy1h1ar6eode4j30e607zgm4.jpg" alt="image"></p><p>在实际的数字证书体系中，这个受信的第三方被称之为证书授权中心（CA），服务器交给CA进行加密的除了自己的公钥外还包括一些其它的如组织名字，有效期等等其它用于身份证明的信息，加密后的相关数据被赋予了一个新的名字—数字证书。SSL/TLS中采用了数字证书的方法对服务器或客户端做身份验证。</p><p>接下来将详细叙述SSL/TLS如何利用加密技术和数字证书技术来提供安全的信道。</p><h3 id="SSL-TLS-安全传输层的建立"><a href="#SSL-TLS-安全传输层的建立" class="headerlink" title="SSL/TLS****安全传输层的建立"></a>SSL/TLS****安全传输层的建立</h3><p>客户端和服务端之间安全信道的建立分为四个阶段，如下图所示。下面将对这四个结算分别进行介绍。</p><p><img src="https://tva3.sinaimg.cn/mw690/007bwgzIgy1h1ar5ixw8nj30fl0fkgnn.jpg" alt="image"></p><h4 id="阶段一"><a href="#阶段一" class="headerlink" title="阶段一"></a>阶段一</h4><p>在CS(客户端-服务端)模式下，首先发起通宵的一般都是客户端，因此提出建立SSL连接的也是客户端。客户端（通常是浏览器）首先向服务器发送一个需要进行加密通信的请求，该信息被称之为ClientHello。在该步骤中，客户端主要向服务端提供如下的信息:</p><ol><li><p>客户端支持的SSL/TLS协议版本；</p></li><li><p>支持加密套件。所谓的加密套件，就是一套流程中会使用到的加密算法，如RSA等等。客户端会向服务器发送自己所知道的所有加密套件，但是最终采用哪一种完全取决与服务器的选择；</p></li><li><p>一个由客户端生成的随机数，该数字会用于后面的密钥生成。</p></li></ol><h4 id="阶段二"><a href="#阶段二" class="headerlink" title="阶段二"></a>阶段二</h4><p>阶段二的主要行为是服务器应答。服务器在收到客户端的问候消息后会对其提供的协议版本，支持的加密算法等信息做检查，如果服务器接受所有条件，则会向客户端发送SeverHello消息，以及如下的内容：</p><ol><li><p>本次会话中要使用的协议版本。服务器会从客户端提供的协议版本选择一个接下来使用的具体版本信息，用于本次会话的协议规范；</p></li><li><p>从客户端提供的加密套件中选择一个接下来要使用的加密套件；</p></li><li><p>服务器证书。服务器会将事先从CA中申请的证书发送给客户端，关于证书的原理详见2.2节，这里不再赘述。</p></li><li><p>一个由服务器生成的随机数，该随机数同样会被用来生成密钥。</p></li></ol><p>至此，客户端和服务端已经约定了如下信息：本次会话使用的协议版本、接下来要使用的加密算法、以及由双方生成的随机数。</p><h4 id="阶段三"><a href="#阶段三" class="headerlink" title="阶段三"></a>阶段三</h4><p>客户端在收到服务端发送的回应后，会首先使用CA提供的凭据验证其证书，如果证书不是由可信机构颁发，或者证书中出现其包含的服务器信息与实际的信息不一致等问题，客户端就会认为该服务器不可信进而给用户发出警告或直接中断通信。如果证书没有出现问题客户端则会向服务器发送如下信息：</p><ol><li><p>由服务器的公钥加密的pre master key。该值的生成方式以及内容由具体的加密套件而定，如果采用的是RSA加密，那么该值则为客户端生成的一个随机数。双方会使用该pre master key以及之前产生的两个随机数共同生成消息传输过程中使用的对称密钥，该密钥用于后面所有实际内容的对称加密；</p></li><li><p>消息改变通知，该通知的含义是告知服务器接下来的所有消息都用约定好的加密套件和密钥进行加密传输。</p></li><li><p>客户端结束握手的消息，该消息会包含之前发的所有消息的哈希值，用于交给服务器进行校验。</p></li></ol><h4 id="阶段四"><a href="#阶段四" class="headerlink" title="阶段四"></a>阶段四</h4><p>服务端在收到客户端发送的pre master key后也会使用与客户端相同的方法计算本次会话使用的对称密钥，接着向客户端发送如下消息以结束信道的建立工作：</p><ol><li><p>消息改变通知，表示随后的信息都将使用双方使约定的加密算法加密后再发送；</p></li><li><p>服务端的结束握手消息，和客户端一样，该通知也包含之前所有消息的哈希值，用于交给客户端进行校验。</p></li></ol><p>至此，双方就在HTTP协议之下建立起了一个可以安全通信的信道，将不安全的HTTP封装成为了相对安全的HTTPS。</p><h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><p>  安全性总是相对的。TLS/SSL所能提供的保护也受到浏览器的实现以及服务端软件所支持的加密算法等因素的影响。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
      <tag>安全</tag>
      
      <tag>Http</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gzip是如何压缩文件的</title>
    <link href="/2021/12/27/Gzip%E6%98%AF%E5%A6%82%E4%BD%95%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6%E7%9A%84/"/>
    <url>/2021/12/27/Gzip%E6%98%AF%E5%A6%82%E4%BD%95%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<h2 id="Gzip-是如何工作的"><a href="#Gzip-是如何工作的" class="headerlink" title="Gzip 是如何工作的"></a>Gzip 是如何工作的</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Gzip使用<code>deflate</code>算法对数据流进行压缩，该算法分1-9一共9个压缩等级，等级越低压缩率越低压缩速度越快。下面使用默认的6级来来说明。<code>Deflate</code>算法该分为LZ77和霍夫曼编码两个部分：前者负责压缩，后者负责编码（其实编码和压缩是一个意思）这里使用字符串<code>abcabcaaabaaa</code>为例来描述算法的总体流程：Gzip首先使用LZ77算法来对该字符串做压缩，得到如下的LZZ编码串（括号和逗号只是为了方便理解，不包括在LZZ编码串内）：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">abc</span><span class="hljs-params">(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>)</span><span class="hljs-title">aaab</span><span class="hljs-params">(<span class="hljs-number">4</span>,<span class="hljs-number">3</span>)</span></span><br></code></pre></td></tr></table></figure><p>这其中的abc就是表示直接把原来的abc复制过来，<code>(4,3)</code>表示从该位置前方4个字符开始往后的三个字符赋值到当前位置，也就是重复一次abc。在这样一个串中，称abc为未匹配的字符串字面量，简称字面量。<code>(distance,length)</code>称为一个有序匹配对，简称匹配对，其中distance表示距离，length表示匹配串的长度。</p><p>​    </p><p>下面针对这两个部分做详细解释。</p><h3 id="LZ77算法"><a href="#LZ77算法" class="headerlink" title="LZ77算法"></a>LZ77算法</h3><p>在gzip的实现中，LZ77需要对一个串找最短匹配长度为3的匹配长度最长的匹配串（也就是最长的相同子串，但是要求最短长度为3）gzip使用数组实现了一个小型的哈希表，哈希的key是根据子串的前三个字符算出来的一个哈希值（这里为方便起见直接使用字符串本身作为哈希值），value是一个链，链中展示了所有以这个三个字符开始的字串的首字母下标位置，下标越大越排在前面。以</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs json">[a a b c a a b c]<br>[<span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span>]<br></code></pre></td></tr></table></figure><p>为例，其哈希表是这样的：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[aab]</span> --&gt;<span class="hljs-selector-attr">[4]</span>-&gt;<span class="hljs-selector-attr">[0]</span><br><span class="hljs-selector-attr">[abc]</span> --&gt;<span class="hljs-selector-attr">[5]</span>-&gt;<span class="hljs-selector-attr">[1]</span><br><span class="hljs-selector-attr">[bca]</span> --&gt;<span class="hljs-selector-attr">[2]</span><br><span class="hljs-selector-attr">[caa]</span> --&gt;<span class="hljs-selector-attr">[3]</span><br></code></pre></td></tr></table></figure><p>后面的匹配过程都是根据这个哈希表来完成。当算法扫描到第一个<code>aab</code>时候，发现<code>aab</code>对应的哈希链是空的，也就是说一定不存在与之相匹配的串，就将其插入哈希表中。持续这样操作直扫描到第二个<code>aab</code>时，算法发现该哈希对应的链上已经链接了其它的字符串，这说明前面已经出现过字符串<code>aab</code>了，于是这里可以得到一个匹配对<code>(4,3)</code>，表示该位置前面存在一个长度为3的相同串。但是这时候算法还不能确定<code>(4,3)</code>就是最后的匹配，因为后面可能还有更长的。这里算法使用了懒惰匹配算法：当出现一个的匹配后，算法不会直接确定该匹配，直到下一个匹配比当前匹配更短，这时候就确定上一个匹配为最佳匹配，并将其写入LZ77编码串中。</p><p>这里LZ77规定匹配串的最小长度是3，最大长度是258。</p><p>每当向LZ77编码串写入一个字符串字面或者写入一个匹配对，Gzip就会对该串频率统计以方便后面的霍夫曼编码。当达到以下条件时算法会对当前的LZ77编码串做一次霍夫曼编码：</p><p>这里首先定义<strong>LZ77编码串的长度为:字符串字面量的个数+匹配对的个数</strong></p><ol><li><p>每当<code>len(lz77_string) % 4096 = 0</code>时（也就是编码串的长度达到一次4096时）进行一次的判定：</p><ol><li>预估的压缩数据的长度小于原始长度的一半（这里的预估是使用一种有较多的冗余编码方法对编码串进行编码后的输出长度）</li><li>匹配对的个数少于未匹配对的个数</li></ol><p>如果以上两个条件都满足，就当前编码串的所有内容进行霍夫曼编码，并清空LZ77编码串缓存。</p></li><li><p>每次LZ77编码串接收新的字符串字面量或者匹配对时：</p><p>如果LZ77串的长度(字符字面量的个数+匹配对的个数达到了32767)或者匹配对的个数达到了32768就进行一次刷洗，将当前的LZ77压缩串传给霍夫曼编码。</p></li></ol><h3 id="霍夫曼编码实现"><a href="#霍夫曼编码实现" class="headerlink" title="霍夫曼编码实现"></a>霍夫曼编码实现</h3><p>前面已经说到，gzip会分别采用静态和动态编码对LZ77压缩串进行压缩，两者唯一的区别是前者如使用内置的固定编码对LZ77的字符串字面量和匹配对进行编码，并将压缩数据写入压缩文件，而后者则使用根据串的频率信息计算出来的编码。</p><p>对于静态编码，内置的编码是什么样的这里不做过多赘述。下面简单叙述一下动态编码的规则。</p><p>gzip把字面量和匹配的长度放到一棵霍夫曼树中，这些一共有286个节点：</p><ol><li>0-255：对应<code>0x00-0XFF</code>中的256种byte</li><li>256：一共霍夫曼压缩块的结束标记</li><li>257-285表示匹配长度的29个范围。由于匹配长度的范围为[3,258],因此这里这里把<code>258+3-1=256</code>个匹配串的长度分配给这29个编码中（实际的编码后面会再跟特定的bit序列来表明具体是哪个值），具体如何分配的这里不再赘述。</li></ol><p>而gzip对距离编码则采用一棵单独的有30个叶子节点的树进行编码，由于距离长度的范围是<code>[1,32768]</code>,因此这里也要把32768个距离值分配到这个30个叶子节点中，也和匹配长度一样，编码后面会跟随特定的比特序列来确定具体是哪一个距离值。由于在接收LZ77编码那个步骤中已经完成了基本的频率统计，因此霍夫曼编码这一步就是根据频率统计信息构建一棵特殊的霍夫曼树，并根据树结构赋予不同的叶子节点不同的编码即可。</p><p>最后gzip依次将或父母编码的元数据(包括编码信息和编码类型等)写入压缩文件,并写入编码后的数据和结束标记，这样就完成了一个压缩数据块的写入工作。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="http://staff.ustc.edu.cn/~yuzhang/ds/gzip/gzip_principle.htm">http://staff.ustc.edu.cn/~yuzhang/ds/gzip/gzip_principle.htm</a></p><p><a href="https://commandlinefanatic.com/cgi-bin/showarticle.cgi?article=art053">https://commandlinefanatic.com/cgi-bin/showarticle.cgi?article=art053</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>简单的RPC框架设计和实现</title>
    <link href="/2021/12/10/%E7%AE%80%E5%8D%95%E7%9A%84RPC%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%AE%9E%E7%8E%B0/"/>
    <url>/2021/12/10/%E7%AE%80%E5%8D%95%E7%9A%84RPC%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>YA-RPC框架（下称本框架）是一个采用C++17编写的简易RPC框架。本框架支持integer,float,string,bool等数据类型，并支持根据服务定义生成相应的RPC服务端代码。</p><h2 id="概要设计"><a href="#概要设计" class="headerlink" title="概要设计"></a>概要设计</h2><p>  本框架主要分RPC服务端和代码生成器两个部分，其中前者提供RPC服务的基础设施，后者根据开发者定义的服务来生成相应的服务代码供给服务端使用。下图展示了本框架的顶层设计：</p><p><img src="https://tva4.sinaimg.cn/mw690/007bwgzIgy1gx8ldcv5btj30l208b3zd.jpg" alt="image"></p><p>  服务定义由库使用者自己编写，类似于GRPC的proto文件，为了简便起见，这里使用了较为通用和易于读写的<code>json</code>格式。代码生成器通过读取服务定义来生成服务代码文件，服务代码文件会预留空白的函数体给库使用者编写具体的服务。库使用者可以在自定义的RPC服务端中添加由代码生成器的服务。    </p><p>  为了便于服务端和客户端之间的消息传递，这里直接使用了<code>websocket</code>来作为消息传输的底层协议。<code>websocket</code>是定义在http协议上层的自带连接的可靠的应用层协议，可以在一定程度上保证消息能够顺利地在客户端和服务端之间传输而不容易丢失。</p><p>  为了使用RPC服务端提供的服务，客户端需要首先和RPC服务端建立连接，然后发送特定格式的包含必要信息的消息给服务端，服务端会调用服务并把结果传送给客户端。这样便完成了一次RPC调用。</p><p>本文编译运行和测试相关环境和使用第三方库如下表所示：</p><table><thead><tr><th>项目</th><th>值</th><th>备注</th></tr></thead><tbody><tr><td>编程语言</td><td>C++17</td><td></td></tr><tr><td>操作系统</td><td>Linux</td><td>64位操作系统</td></tr><tr><td>第三方库</td><td>uWebsockets, nlohmann::json</td><td>均为github的开源仓库</td></tr><tr><td>其它辅助语言</td><td>shellscript,python</td><td>用于辅助测试</td></tr><tr><td>整个框架的详细设计见下一节。</td><td></td><td></td></tr></tbody></table><h2 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h2><h3 id="服务和消息"><a href="#服务和消息" class="headerlink" title="服务和消息"></a>服务和消息</h3><p>  一个RPC服务端应当支持多种服务，每个服务应当支持一种或多种方法，每种方法都有自己的参数列表和返回值类型。因此这里采用如下的<code>json</code>格式来定义一个服务:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;String&quot;</span>,<br>  <span class="hljs-attr">&quot;methods&quot;</span>: [<br>    &#123;<br>      <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;Uppercase&quot;</span>,<br>      <span class="hljs-attr">&quot;params&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;str&quot;</span>: <span class="hljs-string">&quot;string&quot;</span><br>      &#125;,<br>      <span class="hljs-attr">&quot;return&quot;</span>: <span class="hljs-number">1</span><br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p>  其中<code>name</code>定义了服务的名字，<code>method</code>定义了该服务提供的所有方法（函数）列表。列表中的每一项就是一个具体的函数。这样在抽象的层面上，客户端就可以用类似<code>rpc-service.method(args...)</code>的方法来唯一定位自己要调用的服务。因此这里顺便给出客户端的消息（也就是RPC请求）格式：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br><span class="hljs-attr">&quot;client&quot;</span>: <span class="hljs-string">&quot;127.0.0.1&quot;</span>,<br>    <span class="hljs-attr">&quot;service&quot;</span>: <span class="hljs-string">&quot;String&quot;</span>,<br>    <span class="hljs-attr">&quot;method&quot;</span>: <span class="hljs-string">&quot;Uppercase&quot;</span>,<br>    <span class="hljs-attr">&quot;params&quot;</span>:&#123;<br>     <span class="hljs-attr">&quot;str&quot;</span>: <span class="hljs-string">&quot;Hello World&quot;</span>   <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>  其中<code>client</code>是客户端标识，用于给服务端做身份验证和日志记录等工作，本框架为方便期间未使用该字段。<code>service</code>和<code>method</code>定义了客户端想要使用的服务，<code>params</code>给出了该服务所需的参数列表。</p><h3 id="服务端设计"><a href="#服务端设计" class="headerlink" title="服务端设计"></a>服务端设计</h3><p>服务端主要有<code>websocket</code>服务端、工作线程列表、服务列表这三个部分。RPC服务端运行时会监听特定端口，在收到该请求后会对参数进校验和验证，如果失败会直接给客户端发送一个失败的响应，如果成功会尝试调用对应的服务，并把结果封装在成功响应中并发送给客户端，下图展示了服务端的工作流程：</p><p><img src="https://tvax4.sinaimg.cn/mw690/007bwgzIgy1gx8lcnq9m0j30960eigme.jpg" alt="image"></p><p>由于服务端有多个线程，因此其在调用服务的时候不会阻塞IO（在请求不是十分繁忙的时候），下图展示了响应消息的格式：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br><span class="hljs-attr">&quot;code&quot;</span>: <span class="hljs-number">0</span>,<br><span class="hljs-attr">&quot;result&quot;</span>: <span class="hljs-string">&quot;HELLO WORLD&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>  <code>code</code>表示响应的类型，为0的时候表示服务调用成功，结果在<code>result</code>中，不为0的时候表示RPC调用失败，不同的<code>code</code>值代表了不同的错误原因：</p><table><thead><tr><th>状态码</th><th>信息</th></tr></thead><tbody><tr><td>0</td><td>成功</td></tr><tr><td>1</td><td>消息格式错误</td></tr><tr><td>2</td><td>未找到服务</td></tr><tr><td>3</td><td>未找到方法</td></tr><tr><td>4</td><td>身份校验失败</td></tr><tr><td>5</td><td>服务调用超时</td></tr></tbody></table><h3 id="代码生成器"><a href="#代码生成器" class="headerlink" title="代码生成器"></a>代码生成器</h3><p>  由于语言和语义上的原因，RPC无法做到通用的运行时服务生成的功能（某些支持反射的语言或者某些脚本语言除外）。因此需要预先使用第三方程序根据定义来生成代码。对于每个名为<code>Sample</code>的服务都会生成<code>SampleService.h</code>,<code>SampleService.cpp</code>和<code>SampleServiceStub.h</code>三个文件。其中<code>SampleServiceStub</code>是提供给RPC服务端的接口。一个典型的<code>SmapleServiceStub</code>文件如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringServiceStub</span> :</span> <span class="hljs-keyword">public</span> RpcServiceStubInterface &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">StringServiceStub</span><span class="hljs-params">()</span> : <span class="hljs-title">RpcServiceStubInterface</span><span class="hljs-params">(<span class="hljs-string">&quot;String&quot;</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>-&gt;RegisterMethods();<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UppercaseStub</span><span class="hljs-params">(<span class="hljs-keyword">const</span> json &amp;params, RpcResponse &amp;response)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> str = params[<span class="hljs-string">&quot;str&quot;</span>].get&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt;();<br>      <span class="hljs-keyword">auto</span> c = stringService.Len(str);<br>      response.result[<span class="hljs-string">&quot;result&quot;</span>] = c;<br>    &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-built_in">std</span>::exception &amp;e) &#123;<br>      response.result[<span class="hljs-string">&quot;result&quot;</span>] = <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RegisterMethods</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//...</span><br>  &#125;<br><span class="hljs-keyword">private</span>:<br>  StringService stringService;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>  服务中每个具体的方法<code>Method</code>都有一个对应的<code>MethodStub</code>方法，该方法负责将<code>json</code>格式的参数列表解析成对应参数类型的参数列表，由于这部分无法运行时完成，因此也是使用代码生成最主要的原因。在完成参数解析后会将参数传递给由<code>SampleService.h</code>中定义的实际服务。<code>SampleService.h</code>和<code>SampleService.cpp</code>中的内容如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//SampleSerivce.h</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringService</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Len</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> str)</span></span>;<br>&#125;;<br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//sampleService.cpp</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;StringService.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">StringService::Len</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> str)</span> </span>&#123;<br>    <span class="hljs-comment">//供库使用者填写</span><br>&#125;<br></code></pre></td></tr></table></figure><p>  其中CPP文件是空白的函数体，供给库使用者填写具体的服务实现。框架还编写了一个安装脚本<code>install.sh</code>，在管理员权限下可将其安装到系统目录，方便测试使用。</p><h2 id="测试和分析"><a href="#测试和分析" class="headerlink" title="测试和分析"></a>测试和分析</h2><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>  本章节使用单精度浮点类型的求和函数和字符串的转大写服务来进行测试。这里定义前者在<code>Arithmetic</code>服务中，而后者定义在<code>String</code>服务中，两个服务的定义文件如下所示：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;version&quot;</span>: <span class="hljs-number">0</span>,<br>  <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;String&quot;</span>,<br>  <span class="hljs-attr">&quot;methods&quot;</span>: [<br>    &#123;<br>      <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;Uppercase&quot;</span>,<br>      <span class="hljs-attr">&quot;params&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;str&quot;</span>: <span class="hljs-string">&quot;Abc&quot;</span><br>      &#125;,<br>      <span class="hljs-attr">&quot;return&quot;</span>: <span class="hljs-string">&quot;abc&quot;</span><br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;version&quot;</span>: <span class="hljs-number">0</span>,<br>  <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;Arithmetic&quot;</span>,<br>  <span class="hljs-attr">&quot;methods&quot;</span>: [<br>    &#123;<br>      <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;Sum&quot;</span>,<br>      <span class="hljs-attr">&quot;params&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;a&quot;</span>: <span class="hljs-number">1.0</span>,<br>        <span class="hljs-attr">&quot;b&quot;</span>: <span class="hljs-number">1.0</span><br>      &#125;,<br>      <span class="hljs-attr">&quot;return&quot;</span>: <span class="hljs-number">1.0</span><br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p>  并在这两个<code>json</code>所在的目录下运行如下的命令来生成每个服务的源码文件:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">/opt/rpcgen . Test<br></code></pre></td></tr></table></figure><p>  其中<code>rpcgen</code>即为本框架的代码生成器，第二个参数<code>.</code>表示查找当前目录下的定义文件，<code>Test</code>表示该RPC服务器的名称。</p><p>  然后定义<code>TescRpcServer</code>继承自本框架提供的<code>RPCServer</code>基类并添加上方生成的两个服务：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestRPCServer</span> :</span> <span class="hljs-keyword">public</span> RpcServer &#123;<br><span class="hljs-keyword">public</span>:<br>    TestRPCServer(<span class="hljs-keyword">size_t</span> t, <span class="hljs-keyword">uint16_t</span> port) : RpcServer(t, port) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;AddService(<span class="hljs-keyword">new</span> ArithmeticServiceStub());<br>        <span class="hljs-keyword">this</span>-&gt;AddService(<span class="hljs-keyword">new</span> StringServiceStub());<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>  测试的客户端使用由python编写的简单WS客户端做测试，客户端会随机生成测试用例并在本地计算结果，然后将结果和服务端返回的结果做比对，如果二者结果相同就认为该测试用例测试通过。为了测试并发性，这里同时运行4个客户端来向RPC服务端发消息。</p><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><p>下方选取了部分测试结果（客户端输出）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs log">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;SUM TEST&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>[112.25968170166016 &#x3D;&#x3D; 112.25967970499761] &#x3D;&#x3D;&gt; Passed<br>[46.3238639831543 &#x3D;&#x3D; 46.3238626744408] &#x3D;&#x3D;&gt; Passed<br>[77.39429473876953 &#x3D;&#x3D; 77.39429371831518] &#x3D;&#x3D;&gt; Passed<br>[82.80653381347656 &#x3D;&#x3D; 82.80652726251887] &#x3D;&#x3D;&gt; Passed<br>...<br>All sum test passed<br>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;UPPERCASE TEST&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>[BI0QPGTR &#x3D;&#x3D; BI0QPGTR] &#x3D;&#x3D;&gt; Passed<br>[XDUENYVR &#x3D;&#x3D; XDUENYVR] &#x3D;&#x3D;&gt; Passed<br>[M9PBLKHS &#x3D;&#x3D; M9PBLKHS] &#x3D;&#x3D;&gt; Passed<br>[U8N4KFAK &#x3D;&#x3D; U8N4KFAK] &#x3D;&#x3D;&gt; Passed<br>...<br>All sum test passed<br></code></pre></td></tr></table></figure><p>  测试结果显示所有的测试通过。</p><h2 id="总结和展望"><a href="#总结和展望" class="headerlink" title="总结和展望"></a>总结和展望</h2><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>  本文借用了第三方的<code>websocket</code>和<code>json</code>库实现了简单的RPC框架，并使用多个客户端通过了测试。</p><h3 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h3><p>  本次实现的RPC框架还非常简陋，还有很大的改进空间，如：</p><ol><li>不支持自定义的数据类型或者结构体</li><li>在可靠性语义上没有做到明确的区分和定义</li><li>在TCP的基础上做消息传递</li><li>其它等等</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>P=NP?--算法复杂性和NP问题概述</title>
    <link href="/2021/12/08/P-NP-%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%92%8CNP%E9%97%AE%E9%A2%98%E6%A6%82%E8%BF%B0/"/>
    <url>/2021/12/08/P-NP-%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%92%8CNP%E9%97%AE%E9%A2%98%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="问题和多项式时间"><a href="#问题和多项式时间" class="headerlink" title="问题和多项式时间"></a>问题和多项式时间</h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>​    在开始了解P=NP之前需要首先知道“问题”是什么。这里首先对“问题”做一个形式化的定义:<strong>抽象问题Q为问题实例集合I和题解S上的一个二元关系。</strong>例如，对于排序问题的一个实例是：n个正整数和排列顺序(升序或者降序)，题解则为一个有效的排列。</p><p>​    为了简单期起见,NP完全性理论只关注<strong>判定问题</strong>,即题解$S={0,1}$的问题，因此这里可以定义判定问题为<strong>从问题实例集合到题解$S={0,1}$的一个二元关系，</strong>当然也能直接叫函数关系,即$ s = Q(i),s \in {0,1}$ .</p><h4 id="编码和多项式复杂度"><a href="#编码和多项式复杂度" class="headerlink" title="编码和多项式复杂度"></a>编码和多项式复杂度</h4><p>​    编码就是对问题规模的一个形式化的定义。定义抽象集合S(问题实例集合就是一个抽象集合)的编码为S到二进制串集合的映射。在定义编码后，我们就可以对任意一个问题实例i做编码得到其编码$e(i)$.编码$e(i)$的长度就是所谓的问题规模。</p><p>​    如果当提供给算法的是编码长度为$n = |e(i)|$的问题实例i时，算法可以在$O(T(n))$时间内产生问题的解，就说该算法在时间$O(T(n))$内解决完了问题i,特别地，如果$T(n) = n^k$，我们就说该问题是多项式时间内可解的。</p><blockquote><p>注：这里确实挺抽象的，但是仔细想想也不难，主要是把各种各样的问题统一编码称二进制串以便计算机进行解决。</p><p>举个几个例子(自己的理解不一定对)：</p><ol><li>对于整数排序问题：我们把输入的n个数字每个数都编码为32为的二进制串（即计算机中<code>int</code>型整数），一共有n个整数，因此编码总长度是n*32 = 32n，在分析复杂性时候常熟往往是不重要的，因此可以认为该问题的输入规模就是n</li><li>对于问题有n个输入$a_1,a_2,…a_n$的问题P,存在一个可在$O(a_nn)$时间内解决该问题的算法，但是该算法<strong>并不能说是多项式时间内可解</strong>的，因为$a_n$不是编码n的一部分，算法的实际运行时间不仅依赖输入规模n，也依赖编码的实际内容$a_n$,因此是假的多项式时间复杂度。</li></ol></blockquote><h3 id="P类问题"><a href="#P类问题" class="headerlink" title="P类问题"></a>P类问题</h3><p>​    在理解完问题后就能知道什么叫P问题了。定义<strong>复杂类P</strong>为多项式时间内可解的具体判定问题的集合。</p><blockquote><p>说人话就是对于一个(判定)问题，如果存在一个多项时间的算法能够将其解决就称该问题为<strong>P类问题</strong>。比如常见的数组排序，最短路径等等。</p></blockquote><p>注意<strong>P是一个问题集合。</strong></p><h3 id="NP类问题"><a href="#NP类问题" class="headerlink" title="NP类问题"></a>NP类问题</h3><blockquote><p>这里没有用形式化表述是因为设计到一些形式语言的知识，懒得深入了。</p></blockquote><p>​    对于一个问题X以及它的一个解C，如果存在一个多项式时间的算法能够验证C确实是X的一个解，则称此类问题为<strong>NP类问题</strong>，或者叫NP问题。比如对于问题“给定数组<code>3 1 2 4 5</code>，求它的一个升序排列“，以及这个问题的一个解<code>C = 1 2 3 4 5</code>，这里很容易（可在多项式时间内）验证排列C是原数组的一个升序排列，因此该问题是一个NP类问题。</p><p>​    <strong>定理</strong> $P \subseteq NP$，即<strong>一个P问题一定是一个NP问题</strong>。</p><p>​    这个定理是很显然的，用求解P问题的一个多项式算法来求出问题P的所有解，并把待验证解和解集合比对即可。</p><h3 id="NP完全性与NPC问题"><a href="#NP完全性与NPC问题" class="headerlink" title="NP完全性与NPC问题"></a>NP完全性与NPC问题</h3><h4 id="规约和NPC"><a href="#规约和NPC" class="headerlink" title="规约和NPC"></a>规约和NPC</h4><p>这里首先定义<strong>问题X能在多项式时间内规约到问题Y</strong>:对于问题X的任意实例x，都能在多项式时间内构造一个问题y的实例使得如果y输出为真时x也输出为真。该规约过程也记为$X \leq _pY $。</p><p>这里谈谈对这句话的理解，由于Y是在X的基础上在多项式时间内转化而来的，因此如果能够解决Y那就一定能解决X了(先把问题X转化为Y，再解决Y就能得到X的一个解）,且<strong>解决问题Y的算法一定不比问题X简单</strong>：</p><ul><li><p>如果Y是P问题，存在一个多项式算法Q，那么解决X的算法就是多项式时间的规约步骤+Q，结果还是多项式算法，因此Q也是P问题。</p></li><li><p>如果Y不是P问题，那么不存在一个多项式算法Q，但是这里X可能可以不用规约到Y就能有多项式算法，当然也可能没有，因此Q可能是P问题也可能不是。</p></li></ul><p>这就是规约采用$\leq$而不是$=$的原因了。</p><p>在前面我们知道NP问题只有多项式时间的验证算法而不一定有解决算法。在知道规约的概念后，我们自然会想到，存不存在一个问题<code>Y</code>，能让所有的NP问题X都规约到Y,然后再把问题Y解决，那么所有的NP问题不就都解决了吗？</p><p>巧了，这样的问题还真有，也就是人们常说的<strong>NPC问题</strong>，也叫NP完全问题，下面给出该问题的标准定义：</p><p><strong>对于NP问题Y,如果对于任意的NP问题X，都有$X \leq_p Y$,那么Y被称为NPC问题。</strong></p><p>既然满足我们要求的所有问题都能在多项式时间内规约到Y的问题有了，那我们在多项式时间内解决它不就行了吗？只能说还是太天真了。到目前位置，没有人能证明NPC问题能在多项式时间内解决，也没人能证明不能。</p><p><strong>定理</strong> <strong>对于NPC问题Y，P能在多项式时间内解决当且仅当P=NP</strong></p><p>下面给出证明：</p><ol><li>&lt;== 如果P=NP,因为Y是NP问题所以Y也是P问题，所以Y能在多项式时间内解决</li><li>==&gt; 如果Y能在多项式时间内解决，所以Y是P问题，所以$NP \subseteq P$，又因为$P \subseteq NP$,所以$P= NP$</li></ol><p>这就是所谓的P=NP问题。</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>时间复杂度</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>谈谈对分布式系统的理解</title>
    <link href="/2021/12/07/%E8%B0%88%E8%B0%88%E5%AF%B9%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <url>/2021/12/07/%E8%B0%88%E8%B0%88%E5%AF%B9%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<blockquote><p>写这篇已经是00.20了，本来打算10点开始写的，但是<del>空洞骑士太好玩了</del>。研一上这学期吃饱了撑的选了一门课《分布式系统》，结果每周两节课都是早上第一节，搞得我几乎一节课没去，但是没办法试还得考，所以花了一点时间拜读了《分布式系统概念和设计》的部分内容，下面的内容全是有感而发，不会设计相关的算法细节。</p></blockquote><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>​    自从互联网被发明以来，这个世界就进入了信息时代。随之而来的就是海量的数据需要维护和存储，量级更大的计算任务需要处理，这些都给传统的计算机带来的全新的挑战：单个计算机已经无法胜任海量的任务了。于是分布式系统这个领域就应运而生了。</p><p>​    在我的理解中，分布式系统就是让多个独立的主机(或者说进程)共同协作，完成传统的单个计算机无法完成的任务。“完成”</p><p>一词看似轻巧，但是认真想想会产生一大堆传统单机器不会出现的问题，如：</p><ol><li>如何保证效率</li><li>如何保证多机的可靠性</li><li>如何方便这个多机系统的伸缩阔扩展</li></ol><p>这些都是一个成熟的分布式系统需要考虑的问题，下面我将慢慢叙述从这些性质发散和得出的一些问题、知识和算法等等。</p><h3 id="通信，资源，事务"><a href="#通信，资源，事务" class="headerlink" title="通信，资源，事务"></a>通信，资源，事务</h3><p>​    人与人协作需要交流，计算当然也需要，计算机的这种”交流“被称之为通信。我们很自然地就能想到，计算机通信需要因特网的参与，但是这并不是我们关注的重点，我们的重点是更上层的东西。举一个例子，A计算机有一条很重要的信息要通告给这个系统的其它所有信息，并且需要这些信息作出回应，这里的问题是如何保证A发出的消息能准确地到达其它所有信息。再比如一个系统需要产生一个代表计算机A做整个系统的日志收集并发送给管理员，这种机制在分布式系统中被称为“选举”，也是需要解决的问题。</p><p>​    资源访问是多机系统协作不能避免的问题。从”资源“这个词我们很容易就能想到的是分布式互斥问题：如何正确地分配一份（或者多份）临界资源给分布式系统？如何避免计算机在争夺资源的过程中发生死锁？如何才能让每个计算机都能公平地对独占资源进行访问而不被饿死？</p><p>​    ”并发“是多机器系统的不可避免的问题，在涉及到数据读写的问题时就更是如此。假设两个系统A和B”并发地“向计算机C提交一个事务，如何保证这两个并发事务的ACID特性？加锁？还有更好的方法吗？事务调度也是分布式系统（所有的存在并发的系统）中很重要的问题，除了简单加锁外，还有乐观并发控制，时间戳事务控制法等等，每种方法都有自己的优缺点和使用场景。</p><h3 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h3><p>​    一个成熟的分布式系统仅仅是”能运行“肯定是不够的（当然在任何软件中都是如此）。我们应当假设一个分布式系统中每台计算机都不是绝对可靠的，每一台都有故障的可能性（这在现实中是完全合理的）。如果有一天某台计算机突然故障导致数据无法被访问，通信也是永远的timeout,如何保证这个系统还能正常工作呢；再比如说在一个选举过程中，有部分系计算故障产生了错误的值，如何保证这个分布式系统的其它正常的计算机能够”纠正“这个错误呢。对于前者，冗余的计算机是一个很好的方案，但是这也会带来新的问题，如何保证这两台计算机的数据能够始终保持同步呢，对于后者也有一个很著名的”拜占庭将军问题“可供读者参考。</p><h3 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h3><p>​    这里列举的问题只占一小部分，现实中还会出现诸如网络分块、RPC、时钟同步、一致性等各种各样的问题，可以说设计一个高效可靠的分布式系统绝对不是简单的事情，《分布式系统概念和设计》这本书也只能起到一个抛砖引玉的作用。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>写一个简单的用户态文件系统</title>
    <link href="/2021/11/25/%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%94%A8%E6%88%B7%E6%80%81%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <url>/2021/11/25/%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%94%A8%E6%88%B7%E6%80%81%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h3><p>本项目是仿照Linux下的ext4文件系统所编写的一个十分简单的用户态文件系统。本系统用标准的C99编写，在Linux下编译运行通过。本系统做了如下的工作：</p><ol><li>利用普通文件来模拟磁盘，文件系统对磁盘的所有操作均会映射到该文件(下文均简称磁盘文件)上；</li><li>磁盘文件可以随时持久化到本地以及从磁盘加载到内存；</li><li>本文件系统模拟了ext文件系统的超级块，I-node节点表，数据块的bitmap以及数据块表四个部分，所有上层操作都是对这四个部分进行读写；</li><li>本文件系统支持磁盘的创建、格式化、以及文件的创建、写内容和读内容。</li></ol><p>下一节介绍了本文件系统的概要以及详细设计。</p><h3 id="2-概要设计"><a href="#2-概要设计" class="headerlink" title="2. 概要设计"></a>2. 概要设计</h3><p>本文件系统采用分层设计的原则，从底至顶一共分为下面四个层级:</p><ol><li>磁盘布局层。该层提供了对I-node和数据块的创建和销毁的功能以及对超级块的读写功能；</li><li>I-node节点层。该层封装了对i-node的各种操作，包括修改和维护i-node的索引节点以及各种元数据维护。除此之外，该层还提供了对I-node索引的数据块进行数据读写的功能；</li><li>调用接口层。该层向上层提供了创建文件，向文件写入内容和读写内容，以及查看当前目录中文件列表的接口；</li><li>应用层。该层为用户提供了操作磁盘的交互式终端。</li></ol><p>下图展示了本文件系统的基本架构:</p><p><img src="https://tva4.sinaimg.cn/mw690/007bwgzIgy1gwru5ui8cej3046090dfw.jpg" alt="image"></p><h3 id="3-详细设计"><a href="#3-详细设计" class="headerlink" title="3. 详细设计"></a>3. 详细设计</h3><h4 id="3-1-磁盘布局"><a href="#3-1-磁盘布局" class="headerlink" title="3.1 磁盘布局"></a>3.1 磁盘布局</h4><p>本文设计的磁盘布局如下图所示:</p><p><img src="https://tva2.sinaimg.cn/mw690/007bwgzIgy1gwru6d0wdrj30jc01hq2x.jpg" alt="image"></p><p>​    其中超级块(super block)记录了磁盘的元数据，包括每个i-node的大小、i-node的数量、空闲的i-node的数量、每个数据块元数据的大小、每个数据块的大小、磁盘大小等信息。在本系统中，数据块大小固定为1024B。</p><p>​    在初始化一个磁盘时，系统会根据磁盘大小来计算i-node以及数据块的数量，遵循的原则是令i-node占据整个磁盘约1%的空间。为确保不存在碎片空间，系统在实际创建的磁盘时会对磁盘大小做微调。因此创建的磁盘实际大小与用户出入有细微出入。除此之外，每个i-node以及数据块会被分配一个唯一的id以便在需要时进行索引。</p><h4 id="3-2-I-node读写"><a href="#3-2-I-node读写" class="headerlink" title="3.2 I-node读写"></a>3.2 I-node读写</h4><p>本系统中i-node的结构如下图所示:</p><p><img src="https://tva4.sinaimg.cn/mw690/007bwgzIgy1gwru6psxyvj30du0aeab7.jpg" alt="image"></p><p>   I-node包含了文件的各种元数据以及数据块的位置，其中元数据包括i-node节点号，是否被占用，文件模式(类型，权限信息)，用户id，用户组id,修改时间以及链接个数等信息。对于数据块索引，本系统采用直接索引，一级索引和二级索引这三种方式来记录数据块的位置，其中直接索引一共有12个，后面两种间接索引各有一个。一个i-node节点号是8Byte的无符号整数，因此一个1024B的数据块可以存储1024/8=128个块索引，由此可得本文件系统支持的最大文件大小为(128*128+128 + 12) *1024 = 16.137MB。</p><p>与此同时，i-node还维护了一个索引指针，用来指向最后一个指向数据块的索引，以便对数据块的内容进行读写。索引指针就是数据块的块号，磁盘根据块号来读写数据块。</p><p>在初始化磁盘的时候，系统会默认将0号i-node作为根目录”/“的节点号,并为其分配一个数据块用于存储”..”和”.”这两个目录表项。由于本系统暂不支持多级目录，因此每创建一个文件都会在0号i-node的数据块上增加一个文件表项目。每个文件表项记录了文件的名字以及其对应的i-node节点号，其大小为128B,其中文件名占据120B，而I-node节点号占据8B。</p><h4 id="3-3-调用接口"><a href="#3-3-调用接口" class="headerlink" title="3.3 调用接口"></a>3.3 调用接口</h4><p>调用接口层提供了创建文件，读写文件内容的接口。创建文件主要分为两个步骤：</p><ol><li>申请分配一个空闲的的i-node，向该i-node中写入包括文件类型在内的各种元数据；</li><li>将文件名和申请得到的i-node节点号构成的文件表项写入0号i-node的数据块中.</li></ol><p>而对于写文件，系统首先获取该文件所对应的i-node最后一个数据块的指针，然后向其中追加内容，如果数据块被写完就为该i-node分配一个新的数据块，并更新i-node相关数据即可。而对于读文件，原理相似：首先从inode中获取第一个数据块的指针，然后依次遍历属于该i-node的所有数据块，读取内容并存到buffer即可。</p><h4 id="3-4-Shell"><a href="#3-4-Shell" class="headerlink" title="3.4 Shell"></a>3.4 Shell</h4><p>为方便使用，本系统基于上述接口开发了一个简单的shell，并支持如下命令:</p><ol><li><code>init [num]</code>: 创建一个大小为<code>num</code>KB的磁盘并进行格式化</li><li><code>ls</code>列出根目录下的所有文件以及其元数据信息</li><li><code>touch [file]</code>创建一个空文件</li><li><code>cat [file]</code>根据文件名读取该文件的内容并输出到终端</li><li><code>write [file]</code>将从终端标准输入流读取的数据写入文件</li><li><code>save [disk]</code>将磁盘文件保存到本地</li><li><code>load [disk]</code>加载本地磁盘的文件</li><li><code>info</code> 获取磁盘的详细信息，包括每个已经分配的i-node和数据块的内容以及超级块的信息等。</li></ol><p>详细的数据结构见附录。</p><h3 id="4-总结和展望"><a href="#4-总结和展望" class="headerlink" title="4. 总结和展望"></a>4. 总结和展望</h3><p>本系统实现了磁盘布局，文件的创建和读写等功能，完成了要求的任务。但是仍有很大的提升空间，如增加多级目录等功能。</p><h3 id="5-附录"><a href="#5-附录" class="headerlink" title="5. 附录"></a>5. 附录</h3><p>下面展示了各个对象的数据结构:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *超级块</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_block_t</span> &#123;</span><br>    <span class="hljs-keyword">uint32_t</span> magic_number; <span class="hljs-comment">//魔数</span><br>    <span class="hljs-keyword">uint16_t</span> size_of_sb;  <span class="hljs-comment">//超级块的大小</span><br>    <span class="hljs-keyword">uint16_t</span> size_of_inode; <span class="hljs-comment">//inode大小</span><br>    <span class="hljs-keyword">uint16_t</span> size_of_bi; <span class="hljs-comment">//数据块元数据大小</span><br>    <span class="hljs-keyword">uint16_t</span> size_of_block; <span class="hljs-comment">//数据块大小</span><br><br>    <span class="hljs-keyword">uint32_t</span> total_i_cnt; <span class="hljs-comment">//inode数量</span><br>    <span class="hljs-keyword">uint32_t</span> total_b_cnt; <span class="hljs-comment">//数据块数量</span><br>    <span class="hljs-keyword">uint32_t</span> free_i_cnt; <span class="hljs-comment">//空闲的inode数量</span><br>    <span class="hljs-keyword">uint32_t</span> free_b_cnt; <span class="hljs-comment">//空闲的数据块数量</span><br>    <span class="hljs-keyword">uint32_t</span> disk_size;  <span class="hljs-comment">//磁盘大小</span><br>&#125;;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 数据块元数据</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">block_info_t</span> &#123;</span><br>    <span class="hljs-keyword">bool</span> occupied; <span class="hljs-comment">//是否被占用</span><br>    <span class="hljs-keyword">uint16_t</span> space_used; <span class="hljs-comment">//已被写入的数据长度</span><br>    <span class="hljs-keyword">uint32_t</span> number; <span class="hljs-comment">//块号</span><br>    <span class="hljs-keyword">uint32_t</span> inode_number; <span class="hljs-comment">//被索引的inode号</span><br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 数据块</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">data_block_t</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">block_info_t</span> <span class="hljs-title">info</span>;</span> <span class="hljs-comment">//元数据</span><br>    <span class="hljs-keyword">byte_t</span> data[DATA_BLOCK_SIZE]; <span class="hljs-comment">//实际数据</span><br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> *文件表项</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dir_entry_t</span> &#123;</span><br>    <span class="hljs-keyword">char</span> dir_name[<span class="hljs-number">124</span>]; <span class="hljs-comment">//文件名字</span><br>    <span class="hljs-keyword">uint32_t</span> inode_number; <span class="hljs-comment">//inode节点号</span><br>&#125;;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> *文件类型</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">FILETYPE</span> &#123;</span><br>    None = <span class="hljs-string">&#x27;?&#x27;</span>,<br>    Normal = <span class="hljs-string">&#x27;-&#x27;</span>,<br>    Dir = <span class="hljs-string">&#x27;d&#x27;</span>,<br>    Charctor = <span class="hljs-string">&#x27;c&#x27;</span>,<br>    Block = <span class="hljs-string">&#x27;b&#x27;</span>,<br>    Socket = <span class="hljs-string">&#x27;s&#x27;</span>,<br>    Pipe = <span class="hljs-string">&#x27;p&#x27;</span>,<br>    Link = <span class="hljs-string">&#x27;l&#x27;</span><br>&#125;;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> *文件模式</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_mode_t</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">FILETYPE</span> <span class="hljs-title">file_type</span>;</span> <span class="hljs-comment">//文件类型</span><br>    <span class="hljs-keyword">byte_t</span> up: <span class="hljs-number">3</span>; <span class="hljs-comment">//用户权限</span><br>    <span class="hljs-keyword">byte_t</span> gp: <span class="hljs-number">3</span>; <span class="hljs-comment">//组权限</span><br>    <span class="hljs-keyword">byte_t</span> ap: <span class="hljs-number">3</span>; <span class="hljs-comment">//其他人的权限</span><br>&#125;;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> *inode数据结构</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode_t</span> &#123;</span><br>    <span class="hljs-keyword">bool</span> occupied; <span class="hljs-comment">//是否被占用</span><br>    <span class="hljs-keyword">uint32_t</span> number; <span class="hljs-comment">//节点号</span><br>    <span class="hljs-keyword">uint32_t</span> file_size; <span class="hljs-comment">//文件大小</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_mode_t</span> <span class="hljs-title">mode</span>;</span> <span class="hljs-comment">//文件模式</span><br>    <span class="hljs-keyword">int8_t</span> uid; <span class="hljs-comment">//用户id</span><br>    <span class="hljs-keyword">int8_t</span> gid; <span class="hljs-comment">//组id</span><br>    <span class="hljs-keyword">time_t</span> c_time; <span class="hljs-comment">//创建时间</span><br>    <span class="hljs-keyword">time_t</span> m_time; <span class="hljs-comment">//修改时间</span><br>    <span class="hljs-keyword">time_t</span> a_time; <span class="hljs-comment">//访问时间</span><br>    <span class="hljs-keyword">uint8_t</span> links; <span class="hljs-comment">//链接数</span><br>    <span class="hljs-keyword">inode_pointer_t</span> direct[INODE_DIRECT_NUM]; <span class="hljs-comment">//直接索引</span><br>    <span class="hljs-keyword">uint32_t</span> block_used; <span class="hljs-comment">//引用的数据块数量</span><br>    <span class="hljs-keyword">uint16_t</span> cnt_file_num; <span class="hljs-comment">//(当前目录下的文件数量，仅目录类型有效)</span><br>    <span class="hljs-keyword">inode_pointer_t</span> singly; <span class="hljs-comment">//一级索引</span><br>    <span class="hljs-keyword">inode_pointer_t</span> doubly; <span class="hljs-comment">//二级索引</span><br>&#125;;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> *磁盘数据结构(和本地存储的二进制结构不一样)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">disk_t</span> &#123;</span><br>    <span class="hljs-keyword">super_block_t</span> sb; <span class="hljs-comment">//超级块</span><br>    <span class="hljs-keyword">inode_t</span> *inode_list; <span class="hljs-comment">//inod节点表</span><br>    <span class="hljs-keyword">data_block_t</span> *data_block_list; <span class="hljs-comment">//数据块表(包括元数据和实际内容)</span><br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>文件系统</tag>
      
      <tag>C</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>trapdoor 设计思路</title>
    <link href="/2021/11/08/trapdoor-%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF/"/>
    <url>/2021/11/08/trapdoor-%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="原理和设计"><a href="#原理和设计" class="headerlink" title="原理和设计"></a>原理和设计</h1><p>本插件并没有用到什么十分高深的技巧或者技术，完全是在巨人的肩膀上进行的一些微小的工作，<br>毕竟tr最初的名字就叫<code>MCBEToolSet</code>.下面简单介绍下tr的原理和设计。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="HOOK和CALL"><a href="#HOOK和CALL" class="headerlink" title="HOOK和CALL"></a>HOOK和CALL</h3><p>Tr的核心就是基于Win32的hook技术,这也是它不能跨平台的最本质原因(linux上也有相应的技术，只不过没有采用)。</p><p>整个BDS的运行是就是各种函数依次执行的结果(其它软件也是)，不难想到，只要我们可以改动部分函数的逻辑就能在宏观上<br>影响玩家，这就是tr的核心原理。</p><p>hook技术给我们带来了下面两个核心的接口：</p><ol><li>HOOK</li><li>CALL</li></ol><p>HOOK就是能监听特定函数的执行，能让开发者在某个函数执行前和执行后插入部分代码，以及禁止某个函数的执行，下面是表示hook<br>接口的伪代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">def hook(<span class="hljs-function"><span class="hljs-keyword">function</span>,<span class="hljs-title">before</span>,<span class="hljs-title">after</span>,<span class="hljs-title">execute</span>):</span><br><span class="hljs-function">    <span class="hljs-title">before</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    <span class="hljs-title">if</span> <span class="hljs-title">execute</span>:</span><br><span class="hljs-function">     <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span></span><br><span class="hljs-function"><span class="hljs-function">    <span class="hljs-title">after</span>(<span class="hljs-params"></span>)</span></span><br></code></pre></td></tr></table></figure><p>function就是你要监听的函数，before和after就是运行前后要执行的回调代码，而execute就代表是否要执行该函数。<br>举个简单的例子，我在before里面获取当前时间，然后在after里面获取当前时间，然后将两个时间相减就获得了function()的执行时间，<br>这就是<code>mspt</code>和<code>prof</code>的基本原理。</p><p>CALL给开发者提供了手动调用某个函数的能力，下面是该接口的伪代码:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">def call(function,args):<br>    function(args)<br></code></pre></td></tr></table></figure><p>举个例子就是获取玩家坐标，可以手动调用<code>Actor::getPos(Player*)</code>这个函数即可.</p><h3 id="RVA及其计算"><a href="#RVA及其计算" class="headerlink" title="RVA及其计算"></a>RVA及其计算</h3><h4 id="RVA"><a href="#RVA" class="headerlink" title="RVA"></a>RVA</h4><p>知道最基本的原理后另一个问题来了，我们该如何在工程中实现上述想法呢？这个不用担心，前人早就提供了造好的轮子，能让开发者较为方便地对某个函数进行HOOK和CALL. Tr采用了目前BDS插件圈最常见的方案，也就是微软的<a href="https://github.com/microsoft/Detours">Detours</a>库,<code>api/lib/mod.h</code>里面的<code>THOOK</code>和<code>SYMCALL</code>宏就是对该库的简单封装。</p><p>下面要解决的问题就是如何确定要hook的函数原型(包括参数列表和返回值等)和其在内存中的地址。<br>前者可以通过开发者手动指定，这也是上面两个宏需要传原型的原因。后者就需要一定的计算了。这里涉及<br>的底层知识比较多就简单说几句。</p><p>我们可以简单地把(经过分页处理后的虚拟)内存理解成一个简单的街道，进程就是街道中的房子，而函数就是房子内的某个家具，编译软件就是造房子的过程。由于CPU在运行软件的时候需要知道每个函数的具体位置，因此编译软件的时候就要确定每个函数的地址(也就是家具相对于街道的位置信息)， 但是编译器并不知道操作系统会把进程放在哪个地址，因此编译期间传入的地址都是相对房子角落的，等CPU访问该地址的时候 就把这个相对房子角落的地址加上房子在街道的位置就构成了绝对地址，这样才能正常访问。</p><p>在上面的比喻中，家具相对房子的地址(也就是进程空间的地址)就是所谓的RVA(相对虚拟地址)，这个地址是能在编译期确定的。不仅如此，Win32的API还提供了获取房子相对街道地址的函数，也就是<code>GetModuleHandle</code>函数。<code>api/lib/mod.h</code>中的<code>getVA()</code>函数就执行了这个地址相加的过程。</p><h4 id="获取RVA"><a href="#获取RVA" class="headerlink" title="获取RVA"></a>获取RVA</h4><p>让我们继续往下，来看这个RVA如何获取。既然RVA是编译器确定的，那么想获取RVA就只能问编译器了。很巧的是编译器确实提供了这个功能。以MSVC为例，在特定的编译选项下，MSVC编译完成的时候会生成一个<code>pdb</code>格式的二进制附加文件，这个文件提供了该软件所有函数的RVA信息，而BDS的win版release中确实包含了一个<code>pdb</code>文件。</p><p>不仅如此，微软还提供了读取这个<code>pdb</code>文件的工具<code>cvdump</code>，我们可以执行如下命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cvdump -headers -p bdrock_server.exe &gt; dump_sym.txt<br></code></pre></td></tr></table></figure><p>打开<code>dump_sym.txt</code>文件你就能看到这样一个文件：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs fortran">Microsoft (R) Debugging Information Dumper  Version <span class="hljs-number">14.00</span><span class="hljs-number">.23611</span><br>Copyright (C) Microsoft Corporation.  <span class="hljs-built_in">All</span> rights reserved.<br>*** PUBLICS<br>...<br>S_PUB32: [<span class="hljs-number">0001</span>:<span class="hljs-number">0079</span>ACB0], Flags: <span class="hljs-number">00000002</span>, ?tick@ServerLevel@@UEAAXXZ<br>...<br>*** SECTION HEADERS<br><br><br>SECTION HEADER #<span class="hljs-number">1</span><br>   .text <span class="hljs-keyword">name</span><br> <span class="hljs-number">1</span>A1C3EC virtual <span class="hljs-built_in">size</span><br>    <span class="hljs-number">1000</span> virtual address<br> <span class="hljs-number">1</span>A1C400 <span class="hljs-built_in">size</span> of raw <span class="hljs-keyword">data</span><br>     <span class="hljs-number">400</span> <span class="hljs-keyword">file</span> <span class="hljs-keyword">pointer</span> to raw <span class="hljs-keyword">data</span><br>       <span class="hljs-number">0</span> <span class="hljs-keyword">file</span> <span class="hljs-keyword">pointer</span> to relocation table<br>       <span class="hljs-number">0</span> <span class="hljs-keyword">file</span> <span class="hljs-keyword">pointer</span> to line numbers<br>       <span class="hljs-number">0</span> <span class="hljs-keyword">number</span> of relocations<br>       <span class="hljs-number">0</span> <span class="hljs-keyword">number</span> of line numbers<br><span class="hljs-number">60000020</span> flags<br>         Code<br>         (no align specified)<br>         Execute Read<br></code></pre></td></tr></table></figure><p>其中<code>*** PUBLICS</code>和<code>*** SECTION HEADERS</code>之间的每一行就是编译器提供给我们的一个函数的信息，我们以</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">S_PUB32: [<span class="hljs-number">0001</span>:<span class="hljs-number">00452070</span>], Flags: <span class="hljs-number">00000002</span>, ?<span class="hljs-symbol">tick@</span><span class="hljs-symbol">ServerLevel@</span><span class="hljs-meta">@UEAAXXZ</span><br></code></pre></td></tr></table></figure><p>为例看下这行，<code>0001</code>是段号，表示该函数属于哪个段（段相当于房子内的某个区域），<code>0079ACB0</code>是段内地址，<code>?tick@ServerLevel@@UEAAXXZ</code>就是所谓的符号，这个字符串包含了该函数的原型信息。为了计算RVA,我们需要知道该函数所属段的首地址。下面再来看<code>*** SECTION HEADERS</code>下面的部分，不难发现这里正好就是段信息，<code>1000 virtual address</code>给出了该段的相对地址就是1000。综上所述，函数<code>?tick@ServerLevel@@UEAAXXZ</code>的RVA就是0x0079ACB0+0x1000 = 0x0079BCB0.</p><p><code>api/lib/SymHook.h</code>中的地址都是这么算出来的。由于手工计算过于麻烦，所以社区就诞生了一些工具来自动执行这个计算和导出RVA的过程，这也是一般情况下Tr更新的主要成本。</p><h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3><p>Tr源码结构如下所示:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs awk">├───api <span class="hljs-regexp">//</span>游戏接口<br>│   ├───block <span class="hljs-regexp">//</span>方块接口<br>│   ├───commands <span class="hljs-regexp">//</span>命令注册和解析<br>│   ├───entity <span class="hljs-regexp">//</span>实体接口<br>│   ├───graphics <span class="hljs-regexp">//</span>粒子效果接口<br>│   ├───language <span class="hljs-regexp">//</span>多语言支持<br>│   ├───lib <span class="hljs-regexp">//</span>hook库和其它第三方库<br>│   ├───tools <span class="hljs-regexp">//</span>工具,包括日志,向游戏内部发信息,简单的线程池实现等等<br>│   └───world <span class="hljs-regexp">//</span>Level,Dimension接口<br>├───mod  <span class="hljs-regexp">//</span>具体的功能<br>│   ├───config <span class="hljs-regexp">//</span>配置文件<br>│   ├───eval <span class="hljs-regexp">//</span>计算器功能<br>│   ├───fakePlayer <span class="hljs-regexp">//</span>假人通信功能<br>│   ├───<span class="hljs-keyword">function</span> <span class="hljs-regexp">//</span>漏斗计数器,转方块等功能<br>│   ├───os <span class="hljs-regexp">//</span>os相关功能<br>│   ├───player <span class="hljs-regexp">//</span>玩家相关功能<br>│   ├───spawn <span class="hljs-regexp">//</span>刷怪相关功能<br>│   ├───test <span class="hljs-regexp">//</span>一些不太全面的测试<br>│   ├───tick <span class="hljs-regexp">//</span>tick和prof的实现<br>    └───village <span class="hljs-regexp">//</span>村庄相关功能<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Minecraft</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ddfs</title>
    <link href="/2021/05/11/ddfs-0/"/>
    <url>/2021/05/11/ddfs-0/</url>
    
    <content type="html"><![CDATA[<h2 id="Problem-Statement"><a href="#Problem-Statement" class="headerlink" title="Problem Statement"></a>Problem Statement</h2><p>int large storage system,These two can only satisfy one:</p><ul><li><p>low cost</p></li><li><p>high througtput  </p></li></ul><p>==&gt; Disk bottlteneck</p><h2 id="Literature-Summary"><a href="#Literature-Summary" class="headerlink" title="Literature Summary"></a>Literature Summary</h2><ul><li>fingerprint is random </li><li>no special locality</li><li>traditional cache doesn’t work</li></ul><h2 id="Approaches"><a href="#Approaches" class="headerlink" title="Approaches"></a>Approaches</h2><p>2 Challenge</p><ul><li>Variable vs Fixed length</li><li>Segment Size(8KB)</li><li>Fingerprinting</li></ul><p>combination of three methods:</p><ul><li>bloom filter</li><li>Stream-Informed Segment Layout(SISL)</li><li>Locality Preserved Caching</li></ul><h3 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h3><p>HighLevel:</p><ol><li>break file into variable length segment in a <em>content department manner</em></li><li>compute a  fingerprint for each segment<ol><li>identifya segment</li><li>part of a segment descriptor</li></ol></li><li>DDFS does it’s best to store <strong>one copy of each segment</strong></li><li>use <strong>ZL</strong> to compress segment</li></ol><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">[NFS|<span class="hljs-string">  CIFS  </span>|<span class="hljs-string">   VTL] ===&gt; network file system interface</span><br><span class="hljs-string"></span>||<br>||<span class="hljs-string">(netwrok protocal,TCP/IP,etc)</span><br><span class="hljs-string"></span>||<br>-----------------------------------   <br>||<br>||<br>[File Services|<span class="hljs-string">[namespace manager]] ===&gt; generic File Services interface</span><br><span class="hljs-string"></span>||<span class="hljs-string"> </span><br><span class="hljs-string"></span>||<span class="hljs-string">(forward write requests)</span><br><span class="hljs-string"></span>||<span class="hljs-string"> </span><br><span class="hljs-string">[         Content Store           ] ===&gt; breaks data stream into segments , a segment manager</span><br><span class="hljs-string"></span>||<br>||<span class="hljs-string"> (streams )</span><br><span class="hljs-string"></span>||<br>[  segment store   [Segment inedx]]  ==&gt; actual work of deduplication<br>||<br>||<span class="hljs-string"> </span><br><span class="hljs-string"></span>||<br>[       Container Manager         ]<br>                 |<br><span class="hljs-string">               [Disk]</span><br></code></pre></td></tr></table></figure><h4 id="Segment-Store"><a href="#Segment-Store" class="headerlink" title="Segment Store"></a>Segment Store</h4><p>Segment index stores the <strong>map of segment descriptor to segment</strong></p><p>Write:</p><ol><li>Check if a segment is a deplicate</li><li>if not, compress and store it into a container,append Container into Container Manager</li><li>update the container’s index</li></ol><p>Read:</p><ol><li>find container which store the requested segment(throughput sensitive because of disk io)</li><li>read container by invoking Container manager</li><li>unpack and decompress</li></ol><h3 id="Acceleration-Methods"><a href="#Acceleration-Methods" class="headerlink" title="Acceleration Methods"></a>Acceleration Methods</h3><h4 id="Summary-Vector"><a href="#Summary-Vector" class="headerlink" title="Summary Vector"></a>Summary Vector</h4><p>purpose: <strong>reduce number of times</strong> that system goes to disk to look for a duplicate segment</p><p>features:</p><ul><li>In memory</li><li>if lookup() return true, <strong>may be duplicate</strong> ,if return false, <strong>must a new segment</strong></li></ul><p>operarions:</p><ul><li>Init()</li><li>Insert(fingerprint)</li><li>Lookup(fingerprint)</li></ul><p>how to:</p><p>pass</p><h3 id="SISL-Stream-Informed-Segment-Layout"><a href="#SISL-Stream-Informed-Segment-Layout" class="headerlink" title="SISL(Stream Informed Segment Layout)"></a>SISL(Stream Informed Segment Layout)</h3><p>purpose: <strong>create spatial locality</strong>  to enable LPC</p><p>SISL is designed to preserve this locality</p><p>![IMG_0943(20210428-155628)](C:\Users\xhy\Documents\Tencent Files\2602645221\FileRecv\MobileFile\IMG_0943(20210428-155628).PNG)</p><ul><li>independent</li><li>concurrent</li></ul><h3 id="LPC-Locality-Preserved-Cache"><a href="#LPC-Locality-Preserved-Cache" class="headerlink" title="LPC(Locality  Preserved Cache)"></a>LPC(Locality  Preserved Cache)</h3><p>Segment Cache</p><h2 id="Results"><a href="#Results" class="headerlink" title="Results"></a>Results</h2><p>pass</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Deduplication</title>
    <link href="/2021/04/16/Deduplication/"/>
    <url>/2021/04/16/Deduplication/</url>
    
    <content type="html"><![CDATA[<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><ol><li>Chunking</li><li>Fingerprinting</li><li>Duplicate detection</li><li>Update indexes and store data</li></ol><h2 id="Chunking"><a href="#Chunking" class="headerlink" title="Chunking"></a>Chunking</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[  data stream / File /...]</span><br><span class="hljs-selector-attr">[chunk1]</span><span class="hljs-selector-attr">[chunk2]</span>...<span class="hljs-selector-attr">[chunk3]</span><br></code></pre></td></tr></table></figure><p><strong>features</strong>:</p><ul><li>smaller </li><li>nonoverlapping</li></ul><p>3 different <strong>approaches</strong></p><ul><li>Static chunking</li><li>Content-defined chunking</li><li>File-based chunking</li></ul><h3 id="static-chunking"><a href="#static-chunking" class="headerlink" title="static chunking"></a>static chunking</h3><ul><li>fixed size</li><li>fast</li><li><strong>Vulnerable</strong></li><li>seldom used</li></ul><h3 id="content-defined-chunking"><a href="#content-defined-chunking" class="headerlink" title="content-defined chunking"></a>content-defined chunking</h3><h4 id="how"><a href="#how" class="headerlink" title="how"></a>how</h4><ul><li><p>slice window</p><ul><li>windows size = <code>W</code></li><li>hash function <code>f&#39; = f mod n</code></li><li>crop when <code>f&#39; = c</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp">c = C <span class="hljs-comment">//0&lt;c&lt;=n</span><br>w = W<br>chunks = []<br>chunkBuffer = []<br>hash = f<span class="hljs-number">&#x27;</span><br><span class="hljs-keyword">while</span> hasNext():<br>window = window.shift() <span class="hljs-comment">//shift current slice windows</span><br><span class="hljs-keyword">if</span> hash(window) == c:<br><span class="hljs-comment">//meet a hash which equals to C,chunking</span><br>chunnks.append(chunkBuffer)  <br>buffer.clear()<br><span class="hljs-keyword">else</span>:<br>buffer.update() <span class="hljs-comment">//updata currnet chunk buffer</span><br></code></pre></td></tr></table></figure></li><li><p>influence on chunk size</p><ul><li>varaible length</li><li>expected length is approx. <code>n</code> (Probability)</li></ul><h4 id="special-case"><a href="#special-case" class="headerlink" title="special case"></a>special case</h4></li><li><p>very small  or very max chunks</p></li><li><p>solution:  define Min/Max length</p></li></ul><h4 id="process-overhead"><a href="#process-overhead" class="headerlink" title="process overhead"></a>process overhead</h4><ul><li>small string : <strong>good</strong> performance but <strong>bad</strong> chunking properties (?)</li><li>large string:  <strong>good</strong> chunking properties but <strong>huge</strong>  performance impcat</li></ul><p>solve : <strong>rolling Hash</strong> : <code>hash(index) =  f(index-1,str[i]),f(0)  =F0</code></p><h4 id="Rabin-Fingerprints-string-hash-algorithm"><a href="#Rabin-Fingerprints-string-hash-algorithm" class="headerlink" title="Rabin Fingerprints(string hash algorithm)"></a>Rabin Fingerprints(string hash algorithm)</h4><p>Do not understand abstract algebra and cryptography,<strong>Skip for now</strong></p><h2 id="Duplicate-detection"><a href="#Duplicate-detection" class="headerlink" title="Duplicate detection"></a>Duplicate detection</h2><p>to check every chunk, where it is a duplicate or not.calculate one fingerprint for each chunk (such as SHA1)</p><p>problem: SHA1 cost a lot</p><h3 id="bottleneck-index"><a href="#bottleneck-index" class="headerlink" title="bottleneck index"></a>bottleneck index</h3><p><code>total_index_size = single_index_size * file_size /  chunk_size</code></p><p>total index size is too large for large system, can only be stored in disk</p><h3 id="Bloom-Filter"><a href="#Bloom-Filter" class="headerlink" title="Bloom Filter"></a>Bloom Filter</h3><p>find  whether a set <code>S</code> contains element <code>e</code> or not</p><p>DataStructure:</p><ul><li>Bitmap $bitArray$ (size is m)</li><li>k dependent hash functon $ functions =[f1,f2,…fk]$</li></ul><p>API:</p><ul><li><p>inseret(key)</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-keyword">for</span> h <span class="hljs-keyword">in</span> <span class="hljs-built_in">functions</span>:<br>bitArray[h(<span class="hljs-built_in">key</span>)] = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li><li><p>lookup(key)</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">count</span> = 0<br><span class="hljs-keyword">for</span> <span class="hljs-keyword">h</span> <span class="hljs-keyword">in</span> funcitons:<br><span class="hljs-keyword">count</span> += (bitArray[<span class="hljs-built_in">h</span>(key)] == 1?1:0)<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">count</span> == k<br></code></pre></td></tr></table></figure><p>possible of give false positives </p></li></ul><p>possibility of a bit is not set:</p><p>total<code>m</code>bit, <code>n</code> insert,each insert  set <code>k</code> bits  to 1,<strong>each setting is independent of each other</strong>,so for each bit x:<br>$$<br>P(x = 1) =  1- (1-\frac{1}{m})^{nk} =1- e^{-\frac{kn}{m}}<br>$$<br>so false posibitive rate is <strong>approximated</strong>（this expression only give possibility of <code>lookup()</code>return true） by:<br>$$<br>p = (1- e^{-\frac{kn}{m}})^k<br>$$</p><h2 id="Data-Domain-Architecture"><a href="#Data-Domain-Architecture" class="headerlink" title="Data Domain Architecture"></a>Data Domain Architecture</h2><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><span class="hljs-comment">[  File Services       ]</span> ==&gt; FileSystem<br><span class="hljs-comment">[Content store          ]</span> <br><span class="hljs-comment">[Segment Sture  <span class="hljs-comment">[Segment Index]</span>]</span> ==&gt; Deduplication Layer<br><span class="hljs-comment">[Container Manager       ]</span> <br></code></pre></td></tr></table></figure><h3 id="locality-Preserving-Caching"><a href="#locality-Preserving-Caching" class="headerlink" title="locality Preserving Caching"></a>locality Preserving Caching</h3><h4 id="container-store-sequence-of-new-chunks"><a href="#container-store-sequence-of-new-chunks" class="headerlink" title="container(store sequence of new chunks)"></a>container(store sequence of new chunks)</h4><ul><li>size 1-10MB,fixed size</li><li>self-describing(with meta data in header)</li><li>additionlly compressed</li></ul><h4 id="duplicate-detection"><a href="#duplicate-detection" class="headerlink" title="duplicate detection"></a>duplicate detection</h4><p><img src="C:\Users\xhy\Downloads\a.png" alt="a"></p><p>(write segment and update index and update bloom filter)</p><h3 id="sparse-indexing"><a href="#sparse-indexing" class="headerlink" title="sparse indexing"></a>sparse indexing</h3><p><strong>motivation</strong>： keeping  all chunk index in memory too expensive</p><p><img src="C:\Users\xhy\AppData\Roaming\Typora\typora-user-images\image-20210415161825202.png" alt="image-20210415161825202"></p><h2 id="else-can-do"><a href="#else-can-do" class="headerlink" title="else can do"></a>else can do</h2><h3 id="dedupv1-Architecture"><a href="#dedupv1-Architecture" class="headerlink" title="dedupv1 Architecture"></a>dedupv1 Architecture</h3><ul><li>chunking implements fixed size and variable size</li><li>filter chain (like multi-level cache)</li><li>log system</li></ul><h3 id="Compare-by-Hash"><a href="#Compare-by-Hash" class="headerlink" title="Compare-by-Hash"></a>Compare-by-Hash</h3><p>collision probability<br>$$<br>p &lt;= \frac{n(n-1)}{2}* \frac{1}{2^b}<br>$$</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C语言的一些关键字(C语言复习一)</title>
    <link href="/2021/02/15/C%E8%AF%AD%E8%A8%80%E7%9A%84%E4%B8%80%E4%BA%9B%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <url>/2021/02/15/C%E8%AF%AD%E8%A8%80%E7%9A%84%E4%B8%80%E4%BA%9B%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<p>没办法,考研复试要考笔试C语言，这里只能简单复习下了，这篇主要是说下关键字<code>auto static extern register</code>的用法</p><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p><code>static</code>主要有如下三个用法</p><ul><li>在函数内部修饰一个变量</li><li>在.c文件中限制函数的作用域</li><li>在数组参数中限制数组的最小长度</li></ul><h3 id="函数内部修饰变量"><a href="#函数内部修饰变量" class="headerlink" title="函数内部修饰变量"></a>函数内部修饰变量</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br>    i++;<br> j++;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i = %d j = %d\n&quot;</span>, i,j);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>        f();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述代码执行后，i的输出从1依次递增到10，而j永远都是1</p><blockquote><p>这个用法在c++中也能用，可以用来维护一些全局变量</p></blockquote><h3 id="在-c文件中限制作用域"><a href="#在-c文件中限制作用域" class="headerlink" title="在.c文件中限制作用域"></a>在<code>.c</code>文件中限制作用域</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//a.h</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">///a.c</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">helperFunction</span><span class="hljs-params">()</span></span>&#123;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>   helperFunction();<br>&#125;<br></code></pre></td></tr></table></figure><p>这个<code>helperFunction</code>在其它文件中是不可用的，只有在<code>a.c</code>中才能使用</p><blockquote><p>这个用法在C++中也能用，把函数可见性限制在编译单元内，但是C++更推荐直接使用<code>namespace&#123;&#125;</code></p></blockquote><h3 id="在数组参数中限制最小长度"><a href="#在数组参数中限制最小长度" class="headerlink" title="在数组参数中限制最小长度"></a>在数组参数中限制最小长度</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printVec3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[<span class="hljs-keyword">static</span> <span class="hljs-number">3</span>])</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述参数中限制了<code>arr</code>的长度必须大于等于3</p><h2 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h2><p>现在C语言中的<code>auto</code>没啥屌用</p><h2 id="register"><a href="#register" class="headerlink" title="register"></a>register</h2><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vbnet">It<span class="hljs-comment">&#x27;s a hint to the compiler that the variable will be heavily used and that you recommend it be kept in a processor register if possible.</span><br><br>Most modern compilers <span class="hljs-keyword">do</span> that automatically, <span class="hljs-built_in">and</span> are better at picking them than us humans.<br></code></pre></td></tr></table></figure><p><code>register</code>是一个编译提示，提示这个变量很常用，让编译器把这个变量丢CPU的寄存器上以提高读写速度，这个优化在现代编译器中是自动完成的，因此也不用管</p><h2 id="extern"><a href="#extern" class="headerlink" title="extern"></a><code>extern</code></h2><p>这个关键字是用来声明全局变量的，也就是访问跨编译单元的变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//a.h</span><br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> a; <span class="hljs-comment">//声明</span><br><br><span class="hljs-comment">//a.c</span><br><span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>; <span class="hljs-comment">//定义</span><br><br><span class="hljs-comment">//main.c</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,a);<br>&#125;<br></code></pre></td></tr></table></figure><p>如上图，在<code>.h</code>中用<code>extern</code>声明，在<code>.c</code>中定义，然后包含对应的<code>.h</code>文件就能直接访问了</p>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/02/14/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAjava-ssm%E9%A1%B9%E7%9B%AE/"/>
    <url>/2021/02/14/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAjava-ssm%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<hr><p>title: 从零开始搭建java ssm项目<br>categories: java<br>description: 文章的搜索结果描述<br>thumbnail: <a href="https://wx3.sinaimg.cn/large/007bwgzIly1fx1wynax8dj30at03ldfr.jpg">https://wx3.sinaimg.cn/large/007bwgzIly1fx1wynax8dj30at03ldfr.jpg</a><br>mathjax: true<br>date: 2018-11-09 10:48:19<br>tags:<br>​     -    idea<br>​     -  java<br>​     -    web</p><h2 id="用IDEA来进行完整的ssm项目配置（多图）"><a href="#用IDEA来进行完整的ssm项目配置（多图）" class="headerlink" title="用IDEA来进行完整的ssm项目配置（多图）"></a>用IDEA来进行完整的ssm项目配置（多图）</h2><p>1.选择<code>create new project--&gt;maven</code>,把上面方的<code>Crteate from archetype</code>勾上后在列表选择<code>org.apache.maven.archetypes:maven-archetype-webapp</code>,然后点<code>next</code></p><p><img src="http://ws4.sinaimg.cn/large/007bwgzIly1fx1x3u4rt1j30wv0qy417.jpg" alt="image"></p><p>2填上包名和artifactId名字（随便取），点<code>next</code></p><p><img src="http://ws3.sinaimg.cn/large/007bwgzIly1fx1xbbvqd9j30wv0qyjrt.jpg" alt="image"></p><p>3.自行选择是否更改maven的本地仓库路径和配置文件路径（这里是默认的，没改），点<code>finish</code></p><p><img src="http://ws1.sinaimg.cn/large/007bwgzIly1fx1xhb0eruj30wv0qyjs1.jpg" alt="image"></p><p>4.上一步点了<code>next</code>后就到了主界面，这里IDEA会自动配置项目的artifact,左下角会出现一个弹窗，点<code>inport changes</code></p><p><img src="http://ws4.sinaimg.cn/large/007bwgzIly1fx1xf0l0p9j31hc0tj0x9.jpg" alt="image"></p><p>5,此时的项目结构应该是这样的：</p><p><img src="http://wx1.sinaimg.cn/large/007bwgzIly1fx1xiwjcn1j30di0cvmxg.jpg" alt="image"></p><p>6，在<code>main</code>下新建<code>java</code>和<code>resources</code>文件夹</p><p><img src="http://ws1.sinaimg.cn/large/007bwgzIly1fx1xl3abx3j30dp0fzdg7.jpg" alt="image"></p><p>7.右键刚刚创建的<code>java</code>文件夹，选择<code>make dictionary as-&gt;Sources root</code>，同样地，对刚刚创建的<code>resources</code>文件夹选择<code>make dictionary as-&gt; resources root</code></p><p><img src="http://wx1.sinaimg.cn/large/007bwgzIly1fx1xlsehrcj30id0pyq59.jpg" alt="image"></p><p>7.在<code>java</code>目录下创建相应的包，在<code>resources</code>目录下创建<code>config,mapper</code>文件夹，<code>webapp</code>下创建静态资源文件夹，<code>WEB-INF</code>下创建<code>jsp</code>文件夹，全部完成后的目录应该是这样的：</p><p><img src="http://ws3.sinaimg.cn/large/007bwgzIly1fx1xr2favmj30750eljre.jpg" alt="image"></p><p><img src="http://ws1.sinaimg.cn/large/007bwgzIly1fx1xrbvrs4j30820akjrd.jpg" alt="image"></p><p>可以看到对于不同的文件夹idea会给不同的图表，这也是IDEA的智能之处之一。</p><p>8 配置<code>pox.xml</code>添加相应的依赖，<code>&lt;dependency&gt;</code>内容如下(可以根据自己需要进行增减)：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.11<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>jspapi<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jsp-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.public_draft<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>servletapi<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.4-20040521<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-aop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.9.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-aspects<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.9.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>aspectj<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aspectjweaver<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.5.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>aopalliance<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aopalliance<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-beans<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.9.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.9.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.9.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-expression<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.9.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.9.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-tx<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.9.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.9.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.9.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>asm<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>asm<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>20041228.180559<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cglib<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>cglib<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.2.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-logging<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-logging<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javassist<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javassist<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.12.1.GA<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.17<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.25<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-log4j12<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.25<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-simple<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.25<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>9.接下来IDEA会自动更新项目依赖（取决于网速），右下角会有一个叫你更新配置的弹窗，点<code>import changes</code>即可，完后工程目录下的<code>external libeary</code>下会出现刚刚添加的依赖：</p><p><img src="http://ws3.sinaimg.cn/large/007bwgzIly1fx1xxfm9yuj30fn04ajra.jpg" alt="image"></p><p><img src="http://ws2.sinaimg.cn/large/007bwgzIly1fx1xykq0pmj30dt0kq3zd.jpg" alt="image"></p><p>10.在<code>resources/config</code>下创建<code>applicationContext.xml</code><img src="http://ws3.sinaimg.cn/large/007bwgzIly1fx1xzjj40cj315z0qtadh.jpg" alt="image"></p><p>创建好的<code>applicationContext.xml</code>是这样的，点左上角的<code>configapplication context</code> </p><p><img src="http://wx1.sinaimg.cn/large/007bwgzIly1fx1y2nav1sj311z0a2750.jpg" alt="image"></p><p>点<code>create new application context</code>弹出窗口后选OK</p><p><img src="http://wx1.sinaimg.cn/large/007bwgzIly1fx1y3l5po9j30a603ja9y.jpg" alt="image"></p><p><img src="http://ws2.sinaimg.cn/large/007bwgzIly1fx1y4p7z2aj30lj0rmdg7.jpg" alt="image"></p><p>11.用和第10步一模一样的方法在<code>resources/config</code>下创建<code>springmvc.xml</code></p><p><img src="http://wx2.sinaimg.cn/large/007bwgzIly1fx1y6cgdclj30ci04t745.jpg" alt="image"></p><p>12.在<code>resources/config</code>下创建<code>mybatis-config.xml</code>，也就是mybatis的配置文件</p><p><img src="http://wx3.sinaimg.cn/large/007bwgzIly1fx1y9m2z95j30lm0ab3zb.jpg" alt="image"></p><p><img src="http://ws3.sinaimg.cn/large/007bwgzIly1fx1y8lmeh3j30ci04tq2t.jpg" alt="image"></p><p>13.用和12一样的方法创建<code>log4j.properties</code>和<code>db.properties</code>，完成后<code>resources</code>的目录如下：</p><p><img src="http://ws1.sinaimg.cn/large/007bwgzIly1fx1ybkptysj309o07tjrd.jpg" alt="image"></p><p>14.至此，所有文件的创建完成，下面是<code>resources</code>目录下几个配置文件的内容：</p><p><code>db.properties</code>:配置数据库参数</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs properties"><br><span class="hljs-meta">jdbc.url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/boot_crm?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=GMT</span><br><span class="hljs-meta">jdbc.username</span>=<span class="hljs-string">root</span><br><span class="hljs-meta">jdbc.password</span>=<span class="hljs-string">123456</span><br><span class="hljs-meta">jdbc.maxTotal</span>=<span class="hljs-string">30</span><br><span class="hljs-meta">jdbc.maxIdle</span>=<span class="hljs-string">10</span><br><span class="hljs-meta">jdbc.initalSize</span>=<span class="hljs-string">5</span><br><span class="hljs-meta">jdbc.driver</span>=<span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br></code></pre></td></tr></table></figure><p><code>aplicationcontext.xml</code>：spring的核心配置文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-tag"><span class="hljs-string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-tag"><span class="hljs-string">        http://www.springframework.org/schema/context</span></span><br><span class="hljs-tag"><span class="hljs-string">         http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;classpath:config/db.properties&quot;</span>/&gt;</span><span class="hljs-comment">&lt;!--配置配置文件的路径--&gt;</span><br>    <span class="hljs-comment">&lt;!--配置数据源--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.apache.commons.dbcp2.BasicDataSource&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxTotal&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.maxTotal&#125;&quot;</span>/&gt;</span><span class="hljs-comment">&lt;!--最大连接数--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxIdle&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.maxIdle&#125;&quot;</span>/&gt;</span><span class="hljs-comment">&lt;!--最大空闲数--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;initialSize&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.initalSize&#125;&quot;</span>/&gt;</span><span class="hljs-comment">&lt;!--初始连接数--&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--配置mybatis会话工厂--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;configLocation&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;classpath:config/mybatis-config.xml&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--配置mapper扫描器·--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;basePackage&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.agno3.dao&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sqlSessionFactoryBeanName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--配置Service扫描器--&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.agno3&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>springmvc.xml</code>：spring的核心配置文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="hljs-attr">xmlns:mvc</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-tag"><span class="hljs-string">       http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.agno3.controller&quot;</span>/&gt;</span><span class="hljs-comment">&lt;!--controller扫描器--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>/&gt;</span><span class="hljs-comment">&lt;!--注解驱动--&gt;</span><br>    <span class="hljs-comment">&lt;!--静态资源访问映射 （不被拦截器拦截）--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:resources</span> <span class="hljs-attr">mapping</span>=<span class="hljs-string">&quot;/js/**&quot;</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;/js/&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:resources</span> <span class="hljs-attr">mapping</span>=<span class="hljs-string">&quot;/css/**&quot;</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;/css/&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:resources</span> <span class="hljs-attr">mapping</span>=<span class="hljs-string">&quot;/images/**&quot;</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;/images/&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:resources</span> <span class="hljs-attr">mapping</span>=<span class="hljs-string">&quot;/fonts/**&quot;</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;/fonts/&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span><span class="hljs-comment">&lt;!--配置视图解析器的前后缀--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span>  <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/WEB-INF/jsp/&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>mybatis-config.xml</code>：mybatis的配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">configuration</span></span><br><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--这里的培植信息不用了（在spring的培植文件里面）--&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>15.最后就是在<code>web.xml</code>中配置全局拦截器：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">web-app</span> <span class="hljs-meta-keyword">PUBLIC</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot;</span> &gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">display-name</span>&gt;</span>Archetype Created Web Application<span class="hljs-tag">&lt;/<span class="hljs-name">display-name</span>&gt;</span><br><br><br>  <span class="hljs-comment">&lt;!--配置Spring文件监听器--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:/config/applicationContext.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!--spring-mvc 的拦截器--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>spring-mvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:config/springmvc.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>spring-mvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--拦截所有请求--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">welcome-file-list</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">welcome-file</span>&gt;</span>index.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">welcome-file</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">welcome-file-list</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>至此整个ssm框架就搭建完成了23333.</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C++面向对象1</title>
    <link href="/2019/04/26/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1(1)/"/>
    <url>/2019/04/26/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1(1)/</url>
    
    <content type="html"><![CDATA[<h2 id="对象和类"><a href="#对象和类" class="headerlink" title="对象和类"></a>对象和类</h2><p>要解释什么是类,什么是对象还真实很麻烦的事情,但我尽量吧.</p><p>传统的面向过程编程是一步一步地按照顺序执行的。比如说我要计算一个班10个学生的平均成绩，我会先把这10个数据准备好，然后再求和，最后把和再除以10 ，这样一步一步地把结果算出来。这就是所谓的面向过程的编程。</p><p>而面向对象却不一样，程序要操作的是对象(Object).还是刚刚那个程序，从面向对象的角度来说我们要做的是计算<strong>学生</strong>的平均成绩，重心再对学生进行一些操作。而不是计算这一行为。</p><p>那么，何为对象？该怎么描述对象？对象就是实体。在很多情况下，要精准地描述一个对象是很困难的，但是也没有这个需要。在C++的面向对象中，我们要做的仅仅是通过描述对象的一些属性来确定一个对象。</p><p>比如学生对象，在刚刚的例子中，我们不需要关注学生的名字，性别，因为这对解决问题并没有任何帮助，因此在这个例子中用成绩这一属性来描述学生对象就足以。</p><p>下面的例子就是对学生对象的一个描述或者叫约束，它规定了学生这个实体有一个<code>score</code>属性而且这个<code>score</code>属性是<code>int</code>类型的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">student</span>&#123;</span><br><span class="hljs-keyword">int</span> score;<span class="hljs-comment">//score</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>再比如我要描述一个老师对象，需要用到老师的名字，年纪，性别，就可以这样描述。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Teacher</span>&#123;</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> name;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> gender;<br>    <span class="hljs-keyword">int</span> age;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="C-中的类"><a href="#C-中的类" class="headerlink" title="C++中的类"></a>C++中的类</h2><p>上面的对象描述信息就叫做<code>类</code>。</p><ul><li><p>类不是对象，只是对对象的属性的一种描述，一种约束</p></li><li><p>类可以用来生产对象</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>&#123;</span><br><span class="hljs-keyword">int</span> b;<br><span class="hljs-keyword">bool</span> c;<br>&#125;;<span class="hljs-comment">//创建一个类</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    A a;<span class="hljs-comment">//由这个类生产一个叫a的对象</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>举这样一个例子，在浇筑工件的时候我们需要模具来使工件成为我们需要的模样。C++中类的建立和对象的创建也是如此，<code>class&#123;...&#125;;</code>建立了一个叫A的模具,(那模具是不是对象呢：）)，<code>A a;</code>相当于浇筑过程，通过模具A产生了一个叫<code>a</code>的对象。</p><h2 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h2><p>当然我们对对象的，描述不只是有属性，还可以有行为，把对对象的行为描述称为<code>方法</code>,或者叫成员函数?</p><p>在类中可以这样定义方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>&#123;</span><br><span class="hljs-keyword">int</span> a;<br><span class="hljs-keyword">int</span> b;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getA</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> a;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getB</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> b;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>getA()</code>和<code>getB()</code>就是对A类对象的方法的描述。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>面向对象</tag>
      
      <tag>对象</tag>
      
      <tag>类</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络层</title>
    <link href="/2019/02/25/%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    <url>/2019/02/25/%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<p>寒假在家基本看完了谢希仁的《计算机网络》，其中最重要的四五两章感觉看的不明不白的，这里特地做个总结。</p><a id="more"></a><ul><li>IP数据报 分组等词在这里同义</li></ul><h2 id="一些基本概念"><a href="#一些基本概念" class="headerlink" title="一些基本概念"></a>一些基本概念</h2><h3 id="网络层提供的两种服务"><a href="#网络层提供的两种服务" class="headerlink" title="网络层提供的两种服务"></a>网络层提供的两种服务</h3><p>网络层采用的设计思路:</p><ul><li><strong>网络层只提供简单灵活的，无连接的尽最大努力交付的数据报服务</strong></li><li>网络层是<strong>面向无连接</strong>的，不提供服务质量的承诺，数据的可靠性由用户主机来保证</li></ul><h3 id="网际协议IP"><a href="#网际协议IP" class="headerlink" title="网际协议IP"></a>网际协议IP</h3><p>另外三个配套使用的协议：</p><ul><li><p>地址解析协议ARP</p></li><li><p>网际控制·报文协议ICMP</p></li><li><p>网际组管理协议IGMP</p></li></ul><h4 id="虚拟互联网络"><a href="#虚拟互联网络" class="headerlink" title="虚拟互联网络"></a>虚拟互联网络</h4><p>四种中间设备：</p><ul><li>转发器–物理层使用</li><li>网关–网络层以上使用</li><li>网桥–数据链路层使用（两个网络合成一个新的网络（并不是互联网））</li><li>路由器（网络层使用，把多个网络连接形成互联网）</li></ul><p><strong>能用路由器连接起来的互联网都使用了相同的网际协议IP（Internet protocol）</strong></p><p>可以将互联之后的网络称之为虚拟互联网络（internet）,在某些层面上统一了不同的网络，互联网可以由多种异构的网络互相连接而成（统一它们的正是网际协议IP）</p><h4 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h4><p>定义：（第四代，即IPv4）IP地址就是给互联网上的每一台主机（或者路由器）的<strong>每一个接口</strong>分配一个在全世界范围内唯一的32位标识符。<strong>路由器因为有多个端口因此有多个IP地址</strong></p><p>IP地址的编址方法分为以下三个阶段：</p><ul><li>分类的IP地址</li><li>子网的划分</li><li>构成超网</li></ul><h5 id="分类的IP地址"><a href="#分类的IP地址" class="headerlink" title="分类的IP地址"></a>分类的IP地址</h5><p>IP地址分为ABCDE共五类</p><p>ABC类由两个固定长度的字段构成：</p><ul><li><p>第一个字段是网络号（net-id）,用来<strong>标志主机（或者路由器）所连接到的网络</strong></p></li><li><p>第二个是主机号（host-id），用来<strong>标志主机（或路由器）</strong></p></li></ul><p>综上，IP地址可以标志某个特定的端口是哪个网络上的哪个主机：</p><p><strong>IP地址::={网络号，主机号}</strong></p><table><thead><tr><th>IP类别</th><th>网络号位数</th><th>主机号位数</th><th>备注</th></tr></thead><tbody><tr><td>A</td><td>8</td><td>24</td><td>单播地址（一对一通信）</td></tr><tr><td>B</td><td>16</td><td>16</td><td>单播地址</td></tr><tr><td>C</td><td>24</td><td>8</td><td>单播地址</td></tr><tr><td>D</td><td>–</td><td>–</td><td>多播地址</td></tr><tr><td>E</td><td>–</td><td>–</td><td>备用</td></tr></tbody></table><p>IP地址常用<strong>点分十进制法</strong>来表示，如127.0.0.1</p><p>IP地址的指派范围：</p><table><thead><tr><th>网络类别</th><th>最大可指派数</th><th>可指派的网络号</th><th>每个网络中的最大主机数</th></tr></thead><tbody><tr><td>A</td><td>2^7-2</td><td>1–126</td><td>16777214</td></tr><tr><td>B</td><td>2^14-1</td><td>128.1–191.255</td><td>65534</td></tr><tr><td>C</td><td>2^21-1</td><td>192.0.1–255.255.255</td><td>254</td></tr></tbody></table><p>IP地址的重要特点：</p><ul><li>每一个IP地址都由网络号和主机号构成：<ul><li>IP地址管理机构只分配网络号，便于管理</li><li>路由器只根据网络号来转发分组（目的地址不是本网络的时候只用管网络号而不用管具体端口号），减小了路由表的存储空间和减少了查找时间</li></ul></li><li>实际上的IP地址是标志一台主机和一条链路的接口，具有多个端口的主机也有多个IP地址，称为<strong>多归属主机</strong>，最典型的例子是<strong>路由器</strong></li><li>所有的网络都是都是平等的</li></ul><h4 id="IP地址和硬件地址"><a href="#IP地址和硬件地址" class="headerlink" title="IP地址和硬件地址"></a>IP地址和硬件地址</h4><ul><li>物理地址是数据链路层和物理层用的地址</li><li>IP地址是网络层级以上层用的地址</li></ul><p>包含了IP地址的IP数据报是数据链路层的数据报的数据部分，数据链路层看不见IP数据报的IP地址</p><h4 id="地址解析协议ARP"><a href="#地址解析协议ARP" class="headerlink" title="地址解析协议ARP"></a>地址解析协议ARP</h4><p>ARP协议的作用：从网络层使用的<strong>IP地址</strong>解析出数据链路层使用的<strong>硬件地址</strong></p><p>主机（或者路由器）中的IP地址和MAC地址没有绝对地一一对应关系，并且这个关系可能是动态更新的。每一台主机都有一个ARP cache ,里面有<strong>本局域网</strong>上的各个主机和路由器的IP地址到硬件地址的映射关系。把IP协议封装成MAC帧的时候需要使用该协议。 </p><h4 id="IP数据报的构成"><a href="#IP数据报的构成" class="headerlink" title="IP数据报的构成"></a>IP数据报的构成</h4><ul><li><p>版本号 4位</p></li><li><p>首部长度 4位</p></li><li><p>区分服务 8位，一般情况下用不到</p></li><li><p>总长度 16位  总长度 = 首部 + 数据长度</p></li><li><p>标识 16位 分片的数据报组装的序号</p></li><li><p>标志 3位 用来标记前后是否还有分片</p></li><li><p>片偏移 13位 表示某片在整个分片后的数据报的相对位置</p></li><li><p>生存时间 8位 表示数据报在网络中的寿命（TTL）(早期以S作为单位，现在以跳转次数作为单位)</p></li><li><p>协议 8位 指明数据报中的数据使用何种协议</p></li><li><p>首部检验和 对数据报的首部进行检验</p></li><li><p>源地址</p></li><li><p>目的地址</p></li></ul><h3 id="网络层的两个核心问题"><a href="#网络层的两个核心问题" class="headerlink" title="网络层的两个核心问题"></a>网络层的两个核心问题</h3><ul><li>如进行分组转发</li><li>如果更新和维护路由器的路由表<blockquote><p>下面是针对第一个问题的讨论：</p></blockquote></li></ul><h2 id="划分子网"><a href="#划分子网" class="headerlink" title="划分子网"></a>划分子网</h2><p>最本质的变化：从两级IP地址（{网络.主机}）–&gt;三级网络地址（{网络.子网.主机}）</p><p>子网划分的基本思路：</p><ul><li>单位可将所属的网络划分为若干个子网，这些子网对外仍未一个网络</li><li><strong>IP地址::={网络号，子网号，主机号}</strong></li></ul><h3 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h3><p>子网的划分对外部网络不可见</p><p>因此从IP数据报无法看出源主机是否进行了子网的划分</p><p><strong>网络地址 = IP and 子网掩码</strong></p><p>路由器在和相邻网络之间交换路由信息的时候必须<strong>把自己自己所在网络（或子网）的子网掩码告诉相邻路由器</strong></p><p>在路由器路由表中的每一个项目，除了要给出目的的网络地址，也要给出该网络地址的子网掩码</p><h3 id="使用子网时候的分组转发过程"><a href="#使用子网时候的分组转发过程" class="headerlink" title="使用子网时候的分组转发过程"></a>使用子网时候的分组转发过程</h3><ol><li>从收到的数据报的首部提取目的IP地址D</li><li>先判断是否为直接交付。对和本路由器直接相连的网络逐个进行检查，用各网络的子网掩码和D进行AND操作，如果匹配就直接交付，不匹配就是间接交付，执行3</li><li>若路由表中有目的地址为D的特定主机路由，则根据该特定路由进行交付，否则执行4</li><li>对路由表中的每一行，用其中的子网掩码和D逐位与操作，若其结果N与该行的目的网络地址匹配，则根据该路由进行交付，否则执行5</li><li>若路由表中有默认路由，贼按照默认路由2交付，否则报告分组转发出错</li></ol><h2 id="CIDR-构造超网"><a href="#CIDR-构造超网" class="headerlink" title="CIDR 构造超网"></a>CIDR 构造超网</h2><p>CIDR的主要特点：</p><ul><li><p>消除了传统的A，B，C类地址和划分子网的概念，CIDR使得IP地址从三级编程无分类的两级IP地址：</p><p><strong>IP地址::={&lt;网络前缀&gt;,&lt;主机号&gt;}</strong></p></li><li><p>CIDR把网络前缀相同的连续IP地址组成一个CIDR地址块</p></li></ul><p>a.b.c.d/n表示IP a.b.c.d中前n位是网络前缀，后32-n位是主机号</p><h3 id="网络掩码"><a href="#网络掩码" class="headerlink" title="网络掩码"></a>网络掩码</h3><p>a.b.c.d/n的网络掩码前n位是1，后32-n位是0</p><h3 id="超网的分组转发"><a href="#超网的分组转发" class="headerlink" title="超网的分组转发"></a>超网的分组转发</h3><p>CIDR的分组转发过程和之前的并没有什么不同，只不过由于CIDR的特殊性，在进行掩码计算以匹配网络的时候要<strong>优先匹配最长前缀</strong></p><blockquote><p>下面是针对第二个问题：路由表维护 的讨论</p></blockquote><h2 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h2><h3 id="有关路由选择协议的几个基本概念"><a href="#有关路由选择协议的几个基本概念" class="headerlink" title="有关路由选择协议的几个基本概念"></a>有关路由选择协议的几个基本概念</h3><p>路由选择算法的特点：</p><ul><li>算法必须是正确的和完整的</li><li>算法在计算上应简单</li><li>算法应能适应通信量和网络拓扑的变化</li><li>具有稳定性</li><li>具有公平性</li></ul><h3 id="分层次的路由选择协议"><a href="#分层次的路由选择协议" class="headerlink" title="分层次的路由选择协议"></a>分层次的路由选择协议</h3><p>互联网被分为多个较小的<strong>自治系统</strong>（autonomous system，AS），AS内部使用的路由选择协议称为<strong>内部网关协议(IGP)**，如RIP和OSPF，AS之间的路由选择协议称为</strong>外部网关协议（EGP）**,如BGP-4</p><h4 id="内部网关协议RIP和OSPF"><a href="#内部网关协议RIP和OSPF" class="headerlink" title="内部网关协议RIP和OSPF"></a>内部网关协议RIP和OSPF</h4><table><thead><tr><th>属性</th><th>RIP</th><th>OSPF</th></tr></thead><tbody><tr><td>base</td><td>距离向量</td><td>链路状态</td></tr><tr><td>算法</td><td>Ford</td><td>Dijkstra</td></tr><tr><td>效率</td><td>较低</td><td>较高</td></tr><tr><td>内存占用</td><td>较小</td><td>较大</td></tr><tr><td>适用范围</td><td>较小的网络</td><td>较大的网络</td></tr><tr><td>传送方式</td><td>UDP</td><td>IP数据报</td></tr></tbody></table><h4 id="外部网关协议BGP"><a href="#外部网关协议BGP" class="headerlink" title="外部网关协议BGP"></a>外部网关协议BGP</h4><p>略.</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
      <tag>路由器</tag>
      
      <tag>分组转发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>带符号数表示</title>
    <link href="/2018/09/24/%E5%B8%A6%E7%AC%A6%E5%8F%B7%E6%95%B0%E8%A1%A8%E7%A4%BA/"/>
    <url>/2018/09/24/%E5%B8%A6%E7%AC%A6%E5%8F%B7%E6%95%B0%E8%A1%A8%E7%A4%BA/</url>
    
    <content type="html"><![CDATA[<p>最近在看有关数值的表示有关的知识，因为实在太过混乱，所以在这里总结一下，主要讲<strong>原码，反码和补码</strong>这三种表示带符号数的表示方法。</p><a id="more"></a><p>一直在纠结<code>-10010,+100011</code>这样的还没编码的带符号的二进制数字用什么名词来表示，这也是我一开始看这个的时候有点懵逼的主要原因。所以在这里先约定一下：</p><blockquote><p>用X表示<code>-100,+1111</code>这样的还没编码的带符号的二进制数，N表示X的位数，O(Original code)表示X的原码，用I(Inverse code)表示X的补码，用C(Complement code)表示X的补码。</p></blockquote><p>开始之前再来行几点说明：</p><ul><li><p>所以的示范都是一个字节(1Byte)的空间作为样本</p></li><li><p>所有的示意图均为Graphviz所实现</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>原码，反码和补码这三种编码方法有个共通之处就是这三种编码的<strong>最高位都表示它所代表的数的符号，0表示正数，1表示负数</strong>，其余位表示数的大小(绝对值)：</p><p><img src="http://wx1.sinaimg.cn/mw690/007bwgzIly1fvmzuhhthej308a04d0sk.jpg" alt="image"></p><p>也就是说，N位的X的三种编码值O,I,C都有N+1位, <strong>一个字节最多能表示7位的带符号二进制数</strong>.</p></li></ul><h2 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h2><p>原码是最简单的表示法</p><ul><li><p>N位的X对应得原码有N+1位</p></li><li><p>最高位（也称符号位）是符号</p></li><li><p>其余N-1位（也称数值位）是x的绝对值</p></li></ul><p>下面有几个例子：</p><table><thead><tr><th align="center">X</th><th align="center">O</th></tr></thead><tbody><tr><td align="center">+10010</td><td align="center"><strong>0</strong> 10010</td></tr><tr><td align="center">-11100</td><td align="center"><strong>1</strong> 11100</td></tr><tr><td align="center">+100 1111</td><td align="center"><strong>0</strong> 100 1111</td></tr></tbody></table><p>在一个字节上X的分布是这样的：</p><p><img src="http://ws4.sinaimg.cn/mw690/007bwgzIly1fvn4yz4nwij30it04daa1.jpg" alt="image"></p><p>不难发现0有两个原码，<code>1000 0000</code>和<code>0000 0000</code>,这是编码的特殊性造成的</p><p>原码虽然表示直白，很好理解，但在运算的时候会带来不变。</p><h2 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h2><p>对于正数，反码表示法和原码表示法是一样的，他们俩的主要区别是负数的数值位表示上：</p><ul><li><p>正数最高位时0，负数最高位是1</p></li><li><p>对于正数，其余N-1位是X的绝对值</p></li><li><p>对于负数，其余N-1位是X的绝对值再<strong>按位取反</strong></p></li></ul><p>下面是几个例子：</p><table><thead><tr><th align="center">X</th><th align="center">I</th></tr></thead><tbody><tr><td align="center">+10111</td><td align="center"><strong>1</strong> 10111</td></tr><tr><td align="center">+0</td><td align="center"><strong>0</strong> 000</td></tr><tr><td align="center">-100010</td><td align="center"><strong>1</strong>  <u>11101</u></td></tr><tr><td align="center">-0</td><td align="center"><strong>1</strong> <u>11111</u></td></tr></tbody></table><p>同样，下面是反码的分布图：</p><p><img src="http://ws4.sinaimg.cn/mw690/007bwgzIly1fvn5rzs903j30it04d3yh.jpg" alt="image"></p><p>可以看到，下方的+0…+127,-127,…-0,是完全大对称分布的，不难发现以下规律：</p><ul><li><p>同原码一样，0的反码也有两个，<code>0000 0000</code>和<code>1111 1111</code></p></li><li><p>求X的相反数X的反码只需将X的反码按位取反</p></li></ul><h2 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h2><p>现在最常用的还是<strong>补码</strong>,这种最复杂的编码却凭着先天的优势成为三种编码中最常用的一种,补码对于正数的规则和反码，原码完全一样，这里主要说一下负数的反码表示</p><ul><li>负数的最高位还是1，后面N-1位是$2^{N-1}+X$的二进制表示</li></ul><p>下面有几个例子：<br>X = -10010，$2^{7}+(-10010_{2}) = ‭1101110_{2}​$ ,因此X的补码位<code>1 110 1110</code></p><p>下面还是给出它的分布图：<br><img src="http://ws1.sinaimg.cn/mw690/007bwgzIly1fvn68tew6ej30it04d3yh.jpg" alt="image"></p><p>最显著的特点就是<strong>0只有唯一的补码<code>0000 0000</code>**，不仅如此，</strong>负数补码就是在其反码的基础上再加一**：</p><blockquote><p>若X &gt;0:<br>$$<br>X_{O} = X_{I} = X_{C}<br>$$<br>若X&lt;0<br>$$<br>X_{C} = X_{I}+1<br>$$</p></blockquote><p>补码在计算上面有独特的优势：</p><blockquote><p>如果：<br>$$<br>A + B = C<br>$$<br>那么有：<br>$$<br>A_{C} + B_{C} = C_{C}<br>$$</p></blockquote><p>A,B,C是有符号数，I_A,是其对应的补码，然而这个结论在原码和反码上并不成立，这大概就是补码最成功的一点吧，但数据溢出问终究是存在的。</p>]]></content>
    
    
    <categories>
      
      <category>others</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二进制</tag>
      
      <tag>原码</tag>
      
      <tag>补码</tag>
      
      <tag>反码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Graphviz——用代码绘制你的结构图</title>
    <link href="/2018/09/20/Graphviz%E2%80%94%E2%80%94%E7%94%A8%E4%BB%A3%E7%A0%81%E7%BB%98%E5%88%B6%E4%BD%A0%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE/"/>
    <url>/2018/09/20/Graphviz%E2%80%94%E2%80%94%E7%94%A8%E4%BB%A3%E7%A0%81%E7%BB%98%E5%88%B6%E4%BD%A0%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<p>最近在看《大话数据结构》的时候一直不知道书上的那种图是咋画的:</p><p><img src="http://wx4.sinaimg.cn/mw690/007bwgzIly1fvgfft38eoj30ab06zglp.jpg" alt="image"></p><p>直到这两天才偶然发现这个软件<strong>Graphviz</strong>,下面一起来详细看看这个软件</p><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>下面是<a href="https://graphviz.gitlab.io/">官网</a>对graphviz的介绍：</p><blockquote><p>Graph visualization is a way of representing structural information as diagrams of abstract graphs and networks. Automatic graph drawing has many important applications in software engineering, database and web design, networking, and in visual interfaces for many other domains.</p><p>Graphviz is open source graph visualization software. It has several main graph layout programs. See the <a href="https://graphviz.gitlab.io/gallery">gallery</a> for some sample layouts. It also has web and interactive graphical interfaces, and auxiliary tools, libraries, and language bindings</p></blockquote><p>简单地说Graphviz(全称Graph visualization)是开源的专门用于绘制抽象的网络图，结构图的软件（或者是库），不仅如此，它还为提供了它的图形接口，给其他语言提供了相关库等，总而言之就是一个牛逼哄哄的图形库。</p><h2 id="画廊"><a href="#画廊" class="headerlink" title="画廊"></a>画廊</h2><p>下面是一些用graphviz画的图（来自官网）：</p><p><img src="https://wx4.sinaimg.cn/large/007bwgzIly1fvgfqic5uoj302z04ba9y.jpg"></p><p><img src="https://ws1.sinaimg.cn/large/007bwgzIly1fvgfrbgyeaj30d00hit9x.jpg"></p><p><img src="https://ws2.sinaimg.cn/large/007bwgzIly1fvgfszk6akj31mw1by4qp.jpg"></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这一篇好水啊，自己对它的语法也没完全搞清楚，等我把英文文档看完了再来更新Graphviz的教程吧，博客为了这个软件特地开了一个分类。真的好喜欢这个软件233333,终于结束了用Ai,画图和powerPoint  来画图的日子。</p>]]></content>
    
    
    <categories>
      
      <category>graphviz</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件</tag>
      
      <tag>graphviz</tag>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>λ表达式</title>
    <link href="/2018/09/13/%CE%BB%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2018/09/13/%CE%BB%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><h3 id="啥是匿名函数"><a href="#啥是匿名函数" class="headerlink" title="啥是匿名函数"></a>啥是匿名函数</h3><p>在写这篇文章之前我去查了一遍λ表达式，然后就发现了这个东西——匿名函数，至于为啥要说匿名函数，我们以后再说，下面是wiki对匿名函数的定义：</p><blockquote><p>在计算机编程中，匿名函数（英语：anonymous function）是指一类无需定义标识符（函数名）的函数或子程序，普遍存在于多种编程语言中。</p></blockquote><p>相信你们看完后对匿名函数有一个大概印象了。顾名思义，匿名函数就是没名字的函数，你可能会问，一个函数没名字我们咋知道它就是它，是的，我们当然不知道，但是这都建立在多次调用这个函数的前提下，如果一个函数我们只用一次就不需要它了，它还需要名字吗？类似下面的例子：这个异常我们仅仅抛出一次，它还需要名字吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br></code></pre></td></tr></table></figure><p>没错这里的<code>NullPointerException()</code>实例是没名字的，但这样很方便不是吗？<code>new NullPointerException()</code>就是一个匿名的对象，匿名函数也是一样的道理。</p><h2 id="匿名函数咋写"><a href="#匿名函数咋写" class="headerlink" title="匿名函数咋写"></a>匿名函数咋写</h2><p>知道匿名函数是啥后，匿名函数咋写呢（以java为例）？</p><p>先来看一个普通函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>&#123;<br>  <span class="hljs-keyword">int</span> x = a*a;<br>  <span class="hljs-keyword">int</span> y = b*b;<br>  <span class="hljs-keyword">return</span> x+y;<br>&#125;<br></code></pre></td></tr></table></figure><p>普通函数（方法）有以下几个部分：</p><ul><li>返回值类型</li><li>函数名</li><li>参数列表</li><li>函数体</li><li>返回值<br>再来看看这个函数转换成匿名函数后的样子：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) -&gt; &#123;<br>       <span class="hljs-keyword">int</span> x = a*a;<br>       <span class="hljs-keyword">int</span> y = b*b;<br>       <span class="hljs-keyword">return</span>  x+y;<br>   &#125;<br></code></pre></td></tr></table></figure>上面的普通函数和匿名函数的差别还是很明显的，和普通函数相比，匿名函数少了返回值类型，少了函数名，多了一个特殊的符号<code>-&gt;</code>，没错这就是匿名函数的一般写法：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">(参数列表)-&gt;&#123;执行逻辑&#125;<br>()-&gt;&#123;执行逻辑&#125;<span class="hljs-comment">//没返参数的时候前面的括号不能省略</span><br></code></pre></td></tr></table></figure>当然如果执行逻辑只有一行的话可以省去大括号，<code>-&gt;</code>后面只写返回值：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) -&gt; a*b+b*b<br></code></pre></td></tr></table></figure>下面还有几个常见的匿名函数的例子：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">(String s)-&gt;System.out.print(s)<br>(a,b,c)-&gt;a+b+C <span class="hljs-comment">//有的时候传入参数列表也可以省</span><br>a-&gt;a*a <span class="hljs-comment">//一个参数可以省略括号</span><br></code></pre></td></tr></table></figure><p>叨叨完匿名函数可以告诉你们了，<strong>匿名函数就是λ表达式</strong>。</p><h2 id="java中的λ表达式"><a href="#java中的λ表达式" class="headerlink" title="java中的λ表达式"></a>java中的λ表达式</h2><p>下面的内容主要是对《java 和谐技术I》一书中λ表达式部分的总结</p><h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p>java中的某些接口仅仅由一个抽象方法构成，比如线程中常用的<code>Runnable</code>接口里面只有一个抽象方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>唯一目的就是给Thread类来实现，以定义线程在运行过程中的具体实现（也就是<code>run()</code>方法）。下面是一个线程的创建，实现的<code>run()</code>方法就是线程启动时候执行的动作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread thread = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;hello java&quot;</span>);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>为了定义线程的动作又是传入接口，又是实现抽象函数，这样是不是麻烦了一点，能不能直接把<code>run()</code>里面的代码块也就是”动作“当参数传如呢？答案当然是肯定的，这就要借助λ表达式的力量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Runnable r = ()-&gt;System.out.println(<span class="hljs-string">&quot;hello java&quot;</span>);<br>    Thread thread = <span class="hljs-keyword">new</span> Thread(r);<br></code></pre></td></tr></table></figure><p>这样是不是方便多了，上面这段代码最引人注目的地方就是<code>Runnable r = ()-&gt;System.out.println(&quot;hello java&quot;);</code>它<strong>把一个匿名函数（λ表达式）赋给一个接口，匿名函数就是接口内唯一抽象函数的实现</strong>,然后把实现函数后的接口传给<code>Thread</code>,真是不得不佩服java设计者的思想（其实其他语言早就有了，java8才支持这个）。上面的代码还能继续简写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread thread = <span class="hljs-keyword">new</span> Thread(()-&gt;System.out.println(<span class="hljs-string">&quot;hello java&quot;</span>));<br></code></pre></td></tr></table></figure><p>上面就是λ表达式的神奇作用了，我们把这样的接口实现叫<strong>函数式的接口</strong>。顺便一说，函数式接口的传入参数类型已经在要实现的抽象函数里面定义了，因此我们的参数列表不用再写类型，java编译器会自动判断，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Demo d = <span class="hljs-keyword">new</span> Demo(s-&gt;System.out.println(s));<br></code></pre></td></tr></table></figure><h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><p>出乎意料的是，上面的<code>Demo d = new Demo(s-&gt;System.out.println(s));</code>还能继续简化，如果匿名函数调用的是现成的方法，可以用<strong>class::method</strong>的方式进一步简化λ表达式表达式（莫名想到C++），如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">s-&gt;System.out.println(s)<span class="hljs-comment">//简化成下面的class::method,甚至参数都不要了</span><br>System.out::println<br></code></pre></td></tr></table></figure><p>上面两行代码的效果完全是一模一样的，你可能会问编译器怎么知道要打印啥呢？这个其实不用担心，java编译器可以自动识别，再比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">(x,y)-&gt;Math.pow(x,y)<br>Math::pow<br></code></pre></td></tr></table></figure><p>下面两行是一模一样的，我们需要指名的是”干什么“，至于参数处理问题交给编译器自己去分析就好了。除了<strong>class::method</strong>外，我们还能通过相对路径（class是绝对路径）来进行方法引用，主要就是通过<strong>this::method</strong>和<strong>super::method</strong>来引用本类和父类的方法。</p><p>方法引用之外还能用<strong>class::new</strong>来进行构造器引用，由于这样的用法很不常见，这里就不细说了。</p><h3 id="λ表达式的作用域问题"><a href="#λ表达式的作用域问题" class="headerlink" title="λ表达式的作用域问题"></a>λ表达式的作用域问题</h3><p>λ表达式作为一个独立的”动作“，它虽然<strong>可以访问到其外部的变量，但无法修改</strong>，因此个人不建议在λ表达式中访问外部变量，让它保持独立是最好的选择。</p><p>终于完了，可把我累死了。。</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面向对象</tag>
      
      <tag>java</tag>
      
      <tag>匿名函数</tag>
      
      <tag>接口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>闲聊</title>
    <link href="/2018/09/12/%E9%97%B2%E8%81%8A-md/"/>
    <url>/2018/09/12/%E9%97%B2%E8%81%8A-md/</url>
    
    <content type="html"><![CDATA[<p>说好坚持每周一篇的，但是做不到啊，这篇主要来说说这一个月干了啥吧。。。最简单的概括就是，能感到自己在飞速进步，也能感受到自己有多菜。</p><a id="more"></a><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>暑假期间把《大话数据结构》基本看完了，大部分数据结构自己用C/Java写了一遍，但还有几个没写，要么太懒，要么太难，最后我也在八月底画了一张图<br>!<img src="http://wx2.sinaimg.cn/mw690/007bwgzIly1fv77dvufwnj31me1r5h5e.jpg" alt="image"><br>学完数据结构后的收获很大，我不知道上个世纪的数学家或者计算机学家发挥了多大的脑洞或者尽了多大的努力才发现各式各样的数据结构，各式各样的算法。最为印象深刻的当然是那个让我花了最多时间的BST(二叉查找树)以及它各式各样的变种。看完数据结构也预示着我大二上的计算机必修课程基本全部自学完。</p><h2 id="java"><a href="#java" class="headerlink" title="java"></a>java</h2><p>因为学安卓看的java,这门语言真的把我迷住了，数据抽数据结构的零碎时间补充的java相关知识，主要干的事情有下面这些吧：</p><p>知识点：</p><ul><li>重新认识异常抛出</li><li>重新学java集合</li><li>简单学习java多线程</li><li>javaFx图形界面程序开发</li><li>理解λ表达式</li><li>简单认识java泛型</li><li>JDBC的基本使用</li><li>简单了解jsp</li><li>学习Spring</li><li>学习Mybatis<br>项目：</li><li>辅助一个已在工作的工程师完成一个小型java web项目</li><li>用javaFX开发“一本糊涂账”<br>其他：</li><li>购置《java核心技术II》和一本SSM框架的书</li></ul><h2 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h2><p>这个数据也安装学习了一些软件（虽然基本都是一知半解）</p><ul><li>Ai的基本操作</li><li>blender简单建模</li><li>svn的使用</li><li>tomcat服务器的使用</li><li>IDEA的快捷键</li><li>QtCreator的安装</li><li>Navicat使用</li><li>MySQL Server安装<h2 id="其他知识点"><a href="#其他知识点" class="headerlink" title="其他知识点"></a>其他知识点</h2>由于要睡觉了就简单写一下吧：</li><li>简单静态网页（html,css和javascript）</li><li>xml的相关知识（dtd约束等）</li><li>简单回顾了一些C++的面向对象，帮同学完成Qt桌面程序，更加坚定了我选java的决心</li><li>MySQL常用语句（建表，增删查找等）<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2>整个暑假学的东西很多很杂,主要的东西就是数据结构和java,杂七杂八的绝大多数是为了javaEE服务的，还有的一点点主要是出于兴趣了，对了还有一点忘说了，最近已经开始看计算机组成原理的相关东西了（大二下必修课），整个大二的中心是在不影响自己专业课的情况下去学java和一些计算机的大二必修课，一心一意向着自己所热爱的东西去努力。共勉。</li></ul>]]></content>
    
    
    <categories>
      
      <category>小记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最小生成树</title>
    <link href="/2018/08/08/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    <url>/2018/08/08/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<blockquote><p>题图来源：<a href="http://www.nipic.com/show/3/77/30ba1a57bcec814c.html">http://www.nipic.com/show/3/77/30ba1a57bcec814c.html</a>,侵删</p></blockquote><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p>在说最小生成树之前我们必须明确的几点：</p><ul><li>在之前的无向图基础上给每一条边加上权值（weight）后，这个图就是加权图，每一边的权值是可以相加和可以比较大小的（权值一般是数字）</li><li>对于任意一棵树，欧拉给出了下面的等量关系$V = E + 1$</li></ul><p>我还真不知道咋形容生成树是啥。这么说吧，我们把一张图看成一个交通网，顶点就是地点，边就是路，边的权值就是路的长度。现在有拆迁办来了，他们要在满足任意两地之间可以来往的基本前提（两地之间的路可以有其他的点）下只保留尽可能少数量的路。剩下的路和地点构成的图是原来的图的<strong>子图</strong>。不难发现剩下的路是没有环的（通过欧拉公式证明，略取），也就是一棵树，我们把这样的树叫做该图的<strong>生成树</strong>，而所有生成树中所有边的权值之和最小的树称之为该图的<strong>最小生成树</strong>，最小生成树有如下性质</p><ul><li><p>最小生成树有<code>V</code>个顶点(包含了图的所有顶点),<code>V-1</code>条边</p></li><li><p>一个图最小生成树不唯一</p></li></ul><p>下面就来说说最小生成树的算法实现</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="prim算法"><a href="#prim算法" class="headerlink" title="prim算法"></a>prim算法</h3><p>prim算法可以说很简单易懂，但自己的代码不忍直视，所以下面讲原理，代码就不贴了QAQ</p><blockquote><p>prim算法的证明是图论问题，涉及的数学比较多，这里也不说了，主要看看实现步骤：</p></blockquote><ul><li><p><strong>prim算法是子树一步一步扩展的过程</strong>，每经历一步，子树就多一条边，经过<code>v-1</code>次后子树有<code>v-1</code>条边，此时算法结束；</p></li><li><p><strong>prim算法走的是贪心策略</strong>，每一步都寻找与自己相邻边中权值最小的边；</p><h3 id="kruskal算法"><a href="#kruskal算法" class="headerlink" title="kruskal算法"></a>kruskal算法</h3></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图</tag>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深度优先搜索(DFS)</title>
    <link href="/2018/08/07/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-DFS/"/>
    <url>/2018/08/07/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-DFS/</url>
    
    <content type="html"><![CDATA[<h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><p>具体见我的上一篇<a href="http://localhost:4000/2018/08/07/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88bfs%EF%BC%89/">广度优先搜索</a></p><h1 id="DFS的基本策略"><a href="#DFS的基本策略" class="headerlink" title="DFS的基本策略"></a>DFS的基本策略</h1><p>我们还是以上回的那个图为例：</p><p><img src="http://ws2.sinaimg.cn/mw690/007bwgzIly1fu12j125rwj31270juwfk.jpg"></p><h2 id="遍历的顺序"><a href="#遍历的顺序" class="headerlink" title="遍历的顺序"></a>遍历的顺序</h2><p>个人觉得DFS比BFS更好理解，简单来说就是<strong>一条路走到黑，没路再回头的策略</strong>的策略。我们先来看这个例子（这回从0开始）：</p><ul><li>打印0，找一个和0相邻的（未被打印）顶点        （这里4和0之间选4）</li><li>打印4，找一个和4相邻的（未被打印）顶点        （这里只有3）</li><li>打印3，找和3相邻的（未被打印）顶点                （然而并没有）</li><li>回退到4，找到一个和4相邻的（未被打印）顶点（找到了2）</li><li>打印2，找一个和2相邻的（未被打印）顶点        （找到了1）</li><li>打印1，找和1相邻的（未被打印）顶点                   （没有）</li><li>回退，找一个和2相邻的（未被打印）顶点           （  没有）</li><li>回退，找一个和4相邻的（未被打印）顶点           （没有）</li><li>回退，找一个和1相邻的（未被打印）顶点             （没有）</li><li>结束</li></ul><p>不难发现，这和我们走迷宫的套路是一样的(一直往左手边的路走，找不到了回退)，没错，DFS一个最经典的应用便是走迷宫</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><p>根据上面的分析，不难发现DFS是一个<strong>递归</strong>算法，循环调用以达遍历目的，这里为了标记已经打印的点，也采用一个<code>visited[]</code>数组来存储是否打印的情况。代码是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFSUtil</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v,<span class="hljs-keyword">boolean</span> visited[])</span></span>&#123;<span class="hljs-comment">//把遍历部分单独抽出</span><br><span class="hljs-comment">//标记当前的点为已经标记</span><br>visited[v] = <span class="hljs-keyword">true</span>;<br>System.out.print(v+<span class="hljs-string">&quot; &quot;</span>);<span class="hljs-comment">//打印</span><br>Iterator&lt;Integer&gt; i = adj[v].listIterator();<br><span class="hljs-keyword">while</span> (i.hasNext())&#123;<br><span class="hljs-keyword">int</span> n = i.next();<br><span class="hljs-keyword">if</span>(!visited[n])<br>DFSUtil(n,visited);<span class="hljs-comment">//遍历与当前节点相邻的所有未被打印节点</span><br>&#125; <br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span></span>&#123;<br><span class="hljs-keyword">boolean</span> visited[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-keyword">this</span>.V];<br>DFSUtil(v,visited);<br>&#125;<br></code></pre></td></tr></table></figure><p>下面再来看看非递归实现</p><h3 id="非递归实现"><a href="#非递归实现" class="headerlink" title="非递归实现"></a>非递归实现</h3><p>类比BFS的队列存储，BFS可以利用<strong>栈</strong>来存储：</p><ul><li><strong>搜索</strong>是<strong>入栈</strong>的过程：当<strong>栈顶</strong>顶点还有相邻的顶点的时候就将该顶点入栈</li><li><strong>打印</strong>是<strong>出栈</strong>的过程：当<strong>栈顶</strong>顶点已经没有相邻的顶点时就将该顶点出栈（也就是打印的过程）</li></ul><p>下面是一个实例分析：（还是这个图）</p><p><img src="http://ws2.sinaimg.cn/mw690/007bwgzIly1fu12j125rwj31270juwfk.jpg"></p><ul><li><p>（空栈）</p></li><li><p>0 （0入栈）</p></li><li><p>04（0和4相邻，4入栈）</p></li><li><p>043（3和4相邻，3入栈）</p></li><li><p>04（没有顶点和3相邻，3出栈,打印3）</p></li><li><p>042（与栈顶顶点相邻的还有2，2入栈）</p></li><li><p>0421（1和2相邻，1入栈）</p></li><li><p>042（没有顶点和1相邻，1出栈,打印1）</p></li><li><p>04（没有顶点和2相邻，2出栈,打印2）</p></li><li><p>0（没有顶点和4相邻，4出栈,打印4）</p></li><li><p>（没有顶点和0相邻，0出栈,打印0）</p></li></ul><p>这样当栈为空的时候整个遍历就完全结束了，下面是代码（基本和BFS一模一样）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span></span>&#123;<br>    <span class="hljs-comment">//参观过为true</span><br>    <span class="hljs-keyword">boolean</span> visited[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[V];<br>    <span class="hljs-comment">//第一个遍历的节点已经访问，设为true</span><br>    LinkedList&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    visited[s] = <span class="hljs-keyword">true</span>;<br>    stack.push(s);<span class="hljs-comment">//把已经访问的节点加入队列</span><br><br>    <span class="hljs-keyword">while</span> (stack.size()!=<span class="hljs-number">0</span>)&#123;<br>        s = stack.pop();<span class="hljs-comment">//弹出栈顶元素并打印</span><br>        System.out.print(s+<span class="hljs-string">&quot; &quot;</span>);<br>        Iterator&lt;Integer&gt; i = adj[s].listIterator();<br>        <span class="hljs-keyword">while</span> (i.hasNext())&#123;<br>            <span class="hljs-keyword">int</span> n = i.next();<span class="hljs-comment">//若该节点没有访问</span><br>            <span class="hljs-keyword">if</span>(!visited[n])&#123;<br>            visited[n] = <span class="hljs-keyword">true</span>;<span class="hljs-comment">//访问该节点</span><br>            stack.push(n);<span class="hljs-comment">//加入队列</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>就这样，图的遍历结束了。写这两篇加深了我对图的搜索的认识，后面就是最小生成树和最短路径算法了，游戏才刚刚开始。</p>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图</tag>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
      <tag>搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>广度优先搜索（BFS）</title>
    <link href="/2018/08/07/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88bfs%EF%BC%89/"/>
    <url>/2018/08/07/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88bfs%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><p>之前我们说到过图是一种十分混乱的数据结构，因此对图的遍历当然没有对表和树那样清晰和明确。在这一篇和下一篇中我会详细介绍图的两种遍历：<strong>广度优先遍历（BFS）</strong>和<strong>深度优先遍历（DFS）</strong></p><blockquote><p>对于<code>广度优先遍历</code>和<code>广度优先搜索</code>请不要过于纠结，其实是一样的</p></blockquote><p>对于广度优先遍历，我们需要根据提供的初始点给出遍历结果，这里的遍历结果用打印来表示，因此我们的任务是<strong>对于给定的顶点x,利用DFS不重复地打印所有顶点</strong>。下面给出方法的结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BFS</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>    <span class="hljs-comment">//<span class="hljs-doctag">TODO:</span>bfs and print</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>说明：用java不用c的原因是：我们关注的是算法的本身，用c写会有好多不利于我们理解的细节（比如一堆指针的指向），而用java可以封装没有必要的东西，把关注点更多放在算法本身上。</p></blockquote><p>下面来看一下到底什么是BFS.</p><h1 id="BFS的基本策略"><a href="#BFS的基本策略" class="headerlink" title="BFS的基本策略"></a>BFS的基本策略</h1><p>我们以题图（如下）来进行讲解（设遍历的起始点是顶点3）</p><p><img src="http://ws2.sinaimg.cn/mw690/007bwgzIly1fu12j125rwj31270juwfk.jpg"></p><h2 id="遍历的顺序"><a href="#遍历的顺序" class="headerlink" title="遍历的顺序"></a>遍历的顺序</h2><p>BFS类似<strong>树的层次遍历</strong>，也就是一层一层地往下遍历，我们这里定义一下：<strong>在遍历过程中，与第n层直接相连且未定义层数的点为第n+1层</strong>，下面是个例子：</p><ol><li><p>毫无疑问，顶点3是第一层</p></li><li><p>与3只接相连的有顶点4和顶点0，那么顶点4和顶点0是第2层</p></li><li><p>与4相连的点有3，0，2，由于3和0已经是第一二曾，因此未被定义的点只有2，所有顶点2是第三层同意顶点1也是第三层（因为顶点1与处于第二层的顶点0直接相连）</p></li><li><p>所有的点已经定义，分层结束，得到如下的图：</p><p><img src="http://wx4.sinaimg.cn/mw690/007bwgzIly1fu15u3n95sj30u50ibq3o.jpg" alt="image"><br>我们的BFS就是按照第一层到第n层进行遍历的比如这个图的遍历顺序就是： <code>3-&gt;(4,0)-&gt;(1,2)</code>(至于4和0，1和2的顺序得看图是怎么存储的，和BFS的关系不大)。</p></li></ol><h2 id="遍历的实现"><a href="#遍历的实现" class="headerlink" title="遍历的实现"></a>遍历的实现</h2><p>根据上面的分析我们已经能大致分析出遍历的实现了（打印的点即为已经遍历的点）：</p><ol><li>打印顶点3</li><li>找到与顶点3相邻的（且未被打印的）顶点（这里是4和0）</li><li>打印顶点4</li><li>找到与顶点4相邻的（且未被打印的）顶点…</li><li>打印顶点0</li><li>找到与顶点0相邻的顶点（且未被打印的）顶点..</li><li>…</li></ol><p>这样算法流程就清晰了起来。我们还需要注意一点，<strong>先找到的点总是先打印的</strong>，比如我们找到4和0后，先打印4，然后找与4相邻的点，再打印0，然后打印刚刚找到的和4相邻的点……不知聪明的你有没有发现这其中隐含了一个顶点的队列：</p><ul><li>找到与当前点相邻且为被打印的点是一个<strong>入队</strong>的过程</li><li>打印顶点是一个<strong>出队</strong>的过程</li></ul><p>下面是入队和出队的全过程：</p><ul><li>3（3入队）</li><li>340（由3找到的4，0入队）</li><li>40（与3相邻的点找完，3出队）</li><li>402（由4找到2，2入队）</li><li>02（与4相邻的点找完，4出队）</li><li>021（由0找到1，1入队）</li><li>21（与0相邻的点找完，0出队）</li><li>1（没有与2相邻的，2出队）</li><li>（没有与1相邻的，1出队）</li></ul><p>还有最后一个问题就是<strong>如何判断该点是否已经打印</strong>，这个问题很简单，打印的时候用一个数组<code>visited[]</code>存一下，在入队之前检查数组里面的情况，未被打印就入队就ok.</p><p>这样整个过程以及逻辑实现就十分清晰了，只剩最后的代码实现</p><h2 id="代码实现（以邻接图的存储为例）"><a href="#代码实现（以邻接图的存储为例）" class="headerlink" title="代码实现（以邻接图的存储为例）"></a>代码实现（以邻接图的存储为例）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BFS</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span></span>&#123;<br>    <span class="hljs-comment">//参观过为true</span><br>    <span class="hljs-keyword">boolean</span> visited[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[V];<br>    <span class="hljs-comment">//第一个遍历的节点已经访问，设为true</span><br>    LinkedList&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<span class="hljs-comment">//初始化队列</span><br>    visited[s] = <span class="hljs-keyword">true</span>;<span class="hljs-comment">//标记第一个点为已经打印</span><br>    queue.add(s);<span class="hljs-comment">//把第一个节点加入队列</span><br>    <br><span class="hljs-keyword">while</span> (queue.size()!=<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//全部出队==遍历结束</span><br>        s = queue.poll();<span class="hljs-comment">//从队列出一个顶点</span><br>        System.out.println(s +<span class="hljs-string">&quot; &quot;</span>);<span class="hljs-comment">//打印该顶点</span><br>        <span class="hljs-comment">//遍历与s顶点连接的顶点</span><br>        Iterator&lt;Integer&gt; i = adj[s].listIterator();<br>        <span class="hljs-keyword">while</span> (i.hasNext())&#123;<br>            <span class="hljs-keyword">int</span> n = i.next();<span class="hljs-comment">//若该节点没有访问</span><br>            <span class="hljs-keyword">if</span>(!visited[n])&#123;<br>                visited[n] = <span class="hljs-keyword">true</span>;<span class="hljs-comment">//访问该节点</span><br>                queue.add(n);<span class="hljs-comment">//加入队列</span><br>            &#125;<br>        &#125;<br>       &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就完成的BFS,代码理解还是不难的，下一次应该是DFS（深度优先搜索）</p>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图</tag>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
      <tag>搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图</title>
    <link href="/2018/08/05/%E5%9B%BE/"/>
    <url>/2018/08/05/%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="图的简介"><a href="#图的简介" class="headerlink" title="图的简介"></a>图的简介</h2><p>图（graph）是继表，树，之后一个更加混乱的数据结构，表是<strong>线性</strong>的，树好歹具有<strong>层次性</strong>，而图，再怎么看也啥性质也没有。下面就是一张图，用混乱来形容真的毫不为过(记住这个图，以后还会用到)</p><a id="more"></a><p><br><img src="http://wx3.sinaimg.cn/mw690/007bwgzIly1ftza8rtoejj30h30b7q36.jpg" alt="image"></p><p>十分通俗地，字母A-G叫做图的<strong>顶点(Vertices )</strong>,用V来表示，连接这些顶点的黑灰色的边就叫做<strong>边(Edge)</strong>,用E来表示，图就是这些点和边的集合：(V,E).具体可以参见<a href="https://zh.wikipedia.org/wiki/%E5%9B%BE_(%E6%95%B0%E5%AD%A6)">wiki–图</a></p><p>注：有向图，无向图，连通图等这里不过多介绍，默认是无向图</p><h2 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h2><p>既然我们要写图的数据结构就得想办法用代码把图表示出来，总不能让计算机去图像识别吧 :neutral_face: 。下面来看一看图的存储。</p><p>仔细想想一个图可以有两种方式来确定它的特征：</p><ul><li>顶点以及顶点之间是否相连（是否有边）</li><li>边以及边与边是否有交点（0，1，2）个</li></ul><p>不用多说第一种表示方法更加简单明了吧。。。。 :no_mouth: 这样一来就清晰好多了，我们需要用一个数据集合描述<strong>点及点与点之间的关系</strong>，下面来看两种表示法。</p><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>设有<code>V</code>个点，用一个<code>v*v</code>的矩阵$A = a_{ij}$来表示点与点是否连接，如果点1和点2之间有边，那么$a_{12}=a_{21} = 1$，如果点3和4之间没有边相连，那么$a_{34}=a_{43} = 0$,这样一个用一个<code>v*v</code>的矩阵就能唯一表示一个含v个顶点的图了。如下图是一个例子:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css">mermaid<br><br>graph LR<br><span class="hljs-selector-tag">A</span><span class="hljs-selector-attr">[1]</span>---D<span class="hljs-selector-attr">[4]</span><br><span class="hljs-selector-tag">A</span><span class="hljs-selector-attr">[1]</span>---<span class="hljs-selector-tag">B</span><span class="hljs-selector-attr">[2]</span><br><span class="hljs-selector-tag">A</span><span class="hljs-selector-attr">[1]</span>---C<span class="hljs-selector-attr">[3]</span><br>D<span class="hljs-selector-attr">[4]</span>---<span class="hljs-selector-tag">B</span><span class="hljs-selector-attr">[2]</span><br>C<span class="hljs-selector-attr">[3]</span>---D<span class="hljs-selector-attr">[4]</span><br></code></pre></td></tr></table></figure><p>如上一个含有四个顶点的图有（1，3），（1，4），（1，2），（2，4），（3，4）五条边，用矩阵表示为：</p><p>$$ \begin{bmatrix} 0 &amp; 1 &amp; 1&amp;1 \ 1 &amp; 0 &amp; 0&amp;1 \ 1 &amp; 0&amp; 0&amp;1 \ 1&amp;1&amp;1&amp;0 \ \end{bmatrix} $$ </p><p>聪明的你一定不难发现方阵用数组来存储是最方便的吧,下面我给出java代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//MyGraph.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyGraph</span> &#123;</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> V;<span class="hljs-comment">//顶点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[][];<span class="hljs-comment">//数组</span><br>    MyGraph(<span class="hljs-keyword">int</span> v)&#123;<span class="hljs-comment">//构造器</span><br>        <span class="hljs-keyword">this</span>.V = v;<br>        <span class="hljs-keyword">this</span>.<span class="hljs-built_in">array</span> = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[V][V];<span class="hljs-comment">//初始化</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>&#123;<span class="hljs-comment">//添加边的过程就是让矩阵上两个对称的点的距离等于1的过程</span><br>        <span class="hljs-keyword">this</span>.<span class="hljs-built_in">array</span>[a<span class="hljs-number">-1</span>][b<span class="hljs-number">-1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">this</span>.<span class="hljs-built_in">array</span>[b<span class="hljs-number">-1</span>][a<span class="hljs-number">-1</span>] = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p>实际上用矩阵存储图是十分耗内存的，有n个点的图就要n*n的矩阵，所需的存储空间以平方倍增长，这样明显极为不划算，下面提供一种更好也更常用的图的存储方法：<strong>邻接表</strong></p><p>邻接表的思维和邻接矩阵差不多，都是<strong>用一个数据集合来表示点以及点点之间是否有边</strong>，邻接表的思路是这样的：</p><ul><li><p>对于有V个顶点的图，用V个链表来存储点和点之间是否有边(也就是一个链表数组)</p></li><li><p>每个顶点对应一个链表，如果在顶点A与另一顶点B之间添加了一条边，那么让A对应的链表插入B,当然B对应的链表也要插入A</p><p>下面有一张示意图：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ada">mermaid<br><br>graph LR<br>subgraph headerPointer LinkList <span class="hljs-keyword">array</span><br>A<span class="hljs-comment">---B</span><br>B<span class="hljs-comment">---C</span><br>C<span class="hljs-comment">---D</span><br>D<span class="hljs-comment">---E</span><br><span class="hljs-keyword">end</span><br>A<span class="hljs-comment">--&gt;F[B]</span><br>F[B]<span class="hljs-comment">--&gt;G[C]</span><br>B<span class="hljs-comment">--&gt;H[A]</span><br>C<span class="hljs-comment">--&gt;I[A]</span><br>I<span class="hljs-comment">--&gt;J[E]</span><br>E<span class="hljs-comment">--&gt;K[C]</span><br><br></code></pre></td></tr></table></figure></li></ul><p>简单解释一下，这个图有ABCDE五个顶点，<code>A-&gt;B-&gt;C</code>表示A与B和A与C之间有一条边（切记不是A与B,B与C）,<code>C-&gt;A-&gt;E</code>表示C与A,C与E之间有一条边。</p><p>这里每个顶点对应的链表里面节点与节点之间没有前驱和后继的关系,这一点十分重要，最后给出java代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Graph</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> V;<span class="hljs-comment">//节点个数</span><br>    <span class="hljs-comment">//每个节点对应的linkList</span><br>    <span class="hljs-keyword">private</span> LinkedList&lt;Integer&gt; adj[];<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Graph</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> v</span>)</span>&#123;<br>        <span class="hljs-keyword">this</span>.V = v;<br>        <span class="hljs-keyword">this</span>.adj = <span class="hljs-keyword">new</span> LinkedList[v];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i&lt;v;i++)<br>            adj[i] = <span class="hljs-keyword">new</span> LinkedList();<br>    &#125;<br><br>    <span class="hljs-comment">//添加边</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addEdge</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> v,<span class="hljs-built_in">int</span> w</span>)</span>&#123;<br>        adj[v].<span class="hljs-keyword">add</span>(w);<br>        adj[w].<span class="hljs-keyword">add</span>(v);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一篇主要说明了（无向）图是啥，并介绍了两种图的存储结构：邻接矩阵和邻接表。在这里说明一下，以后的有关图的博客都以邻接表作为存储方法。</p><p>当然科学家的脑洞是无限的，图肯定不止这两种存储方法，其他方法不作介绍，如想了解请自行百度/谷歌。</p>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图</tag>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQLite中的建表</title>
    <link href="/2018/06/08/SQlite(2)%E2%80%94%E2%80%94%E8%A1%A8%E7%9A%84%E5%88%9B%E5%BB%BA%E4%BB%A5%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <url>/2018/06/08/SQlite(2)%E2%80%94%E2%80%94%E8%A1%A8%E7%9A%84%E5%88%9B%E5%BB%BA%E4%BB%A5%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>面向的是完全没数据库基础的自己</p><h2 id="创建表-create-a-table"><a href="#创建表-create-a-table" class="headerlink" title="创建表(create a table)"></a>创建表(create a table)</h2><p>先来看看SQL中的建表语句：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> TableName (<br>id <span class="hljs-type">integer</span> ,<br>author <span class="hljs-type">text</span>,<br>price <span class="hljs-type">real</span>,<br>pages <span class="hljs-type">integer</span>,<br><span class="hljs-type">name</span> <span class="hljs-type">text</span>)<br></code></pre></td></tr></table></figure><p>括号里面里面每组是代表一个数据的一项，左端是键名(id,author等)，右边的是基本数据类型，<code>text</code>是文本字符串，<code>integer</code>是带符号的整数，<code>real</code>是浮点数。<br>括号外面已经很明显了，表示创建名为<code>TableName</code>的表。</p><p>而把建表语句转换成字符串后就是这样（其实是简单的字符串拼接）：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">final</span> <span class="hljs-keyword">String</span> CREATE_TABLE = <span class="hljs-string">&quot;create table TableName (&quot;</span>+<br>            <span class="hljs-string">&quot;id integer ,&quot;</span>+<br>            <span class="hljs-string">&quot;author text,&quot;</span>+<br>            <span class="hljs-string">&quot;price real,&quot;</span>+<br>            <span class="hljs-string">&quot;pages integer,&quot;</span>+<br>            <span class="hljs-string">&quot;name text)&quot;</span>;<br></code></pre></td></tr></table></figure><p>下面的代码展示了如何利用button监听来创建表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">button2.setOnClickListener(v -&gt;&#123;<br>            SQLiteDatabase db = dbHelper.getWritableDatabase();<br>            db.execSQL(CREATE_TABLE);<br>        &#125;);<br></code></pre></td></tr></table></figure><p>这样当你点了按钮之后数据库就会多出来一个名为TableName的表。但是如果你第二次点击时应用会闪退，，，因为这个表已经存在，再次点击会发生冲突，解决方法很简单,把<code>create table TableName</code>改成<code>create table if not exists TableName</code>即可。这就是一个完整的建表过程。</p>]]></content>
    
    
    <categories>
      
      <category>android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQL</tag>
      
      <tag>SQLite</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQlite(1)——数据库的创建</title>
    <link href="/2018/06/08/SQlite(1)%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%88%9B%E5%BB%BA/"/>
    <url>/2018/06/08/SQlite(1)%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%88%9B%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Android自带了SQLite数据库，这一篇主要讲SQlite数据库的创建以及自己的一些总结</p><a id="more"></a><h2 id="创建一个数据库"><a href="#创建一个数据库" class="headerlink" title="创建一个数据库"></a>创建一个数据库</h2><p>SQlite 的创建需要如下步骤：</p><ul><li>自定义继承<code>SQLiteOpenHelper</code>的子类</li><li>获取该类的实例</li><li>调用<code>getWritableDatabase()</code>方法</li></ul><h3 id="自定义继承SQLiteOpenHelper的子类"><a href="#自定义继承SQLiteOpenHelper的子类" class="headerlink" title="自定义继承SQLiteOpenHelper的子类"></a>自定义继承<code>SQLiteOpenHelper</code>的子类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.agno3.databasetest;<br><br><span class="hljs-keyword">import</span> android.content.Context;<br><span class="hljs-keyword">import</span> android.database.sqlite.SQLiteDatabase;<br><span class="hljs-keyword">import</span> android.database.sqlite.SQLiteOpenHelper;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyDatabaseHelper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SQLiteOpenHelper</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span>  Context mContext;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> context 上下文</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> name 数据库名</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> factory 不知道 一般填null</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> version 数据库版本</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyDatabaseHelper</span><span class="hljs-params">(Context context, String name, SQLiteDatabase.CursorFactory factory, <span class="hljs-keyword">int</span> version)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(context, name, factory, version);<br>        <span class="hljs-comment">//构造器内传入上下文</span><br>        <span class="hljs-keyword">this</span>.mContext = context;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(SQLiteDatabase db)</span> </span>&#123;<br>    <span class="hljs-comment">//这个方法在数据库被创建的时候执行</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onUpgrade</span><span class="hljs-params">(SQLiteDatabase db, <span class="hljs-keyword">int</span> oldVersion, <span class="hljs-keyword">int</span> newVersion)</span> </span>&#123;<br>      <span class="hljs-comment">//这个方法在数据库版本更新的时候执行</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="获取该类的实例以及创建数据库"><a href="#获取该类的实例以及创建数据库" class="headerlink" title="获取该类的实例以及创建数据库"></a>获取该类的实例以及创建数据库</h3><p>``<br>//MainActivity的oncreate方法<br>protected void onCreate(Bundle savedInstanceState) {<br>       super.onCreate(savedInstanceState);<br>       setContentView(R.layout.activity_main);<br>       //获取MyDatabaseHelper的实例<br>       MyDatabaseHelper dbHelper = new MyDatabaseHelper(this,”BookStore.db”,null,1);<br>       Button button = findViewById(R.id.create_database);<br>       //执行getWritableDatabase()方法<br>       button.setOnClickListener(v-&gt; dbHelper.getWritableDatabase());<br>}</p><pre><code>在执行getWritableDatabase()方法后数据库被创建，但是个没表的新库，会自动生成一个`android_metadata`的table,与此同时，MyDatabaseHelper类中的`onCreate()`方法被执行。getWritableDatabase()的返回值是一个**SQLiteDatabase**对象，在第二次执行getWritableDatabase()方法时数据库不会再被创建，`onCreate()`也不会再次执行，此时可以利用`SQLiteDatabase db = dbHelper.getWritableDatabase()`来获取该数据库的实例，从而对数据库进行进一步操作(增删查改等)。</code></pre>]]></content>
    
    
    <categories>
      
      <category>android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>android</tag>
      
      <tag>SQlite</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次简单的图灵api的使用</title>
    <link href="/2018/05/25/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%9B%BE%E7%81%B5api%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2018/05/25/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%9B%BE%E7%81%B5api%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>今天做了一个小聊天机器人，效果如图，感觉不错就来分享记录一下。</p><a id="more"></a><p><img src="http://ws3.sinaimg.cn/mw690/006dLm93ly1frnv9ukstwj30f00qomxm.jpg" alt="image"></p><h2 id="注册图灵机器人"><a href="#注册图灵机器人" class="headerlink" title="注册图灵机器人"></a>注册图灵机器人</h2><p>在<a href="http://www.tuling123.com/">图灵机器人</a>官网上注册一个账号，并添加一个机器人，获取<code>apikey</code>备用，<code>apikey</code>是外界和机器人交流的唯一接口，注意不要泄露给别人。</p><p><img src="http://ws3.sinaimg.cn/mw690/006dLm93ly1frnvtbh5o1j307m02rwea.jpg" alt="image"></p><h2 id="通过apikey获取答复"><a href="#通过apikey获取答复" class="headerlink" title="通过apikey获取答复"></a>通过<code>apikey</code>获取答复</h2><p>该过程的实质是一个post,请求，也就是携带信息向某个url进行post请求。<br>携带的信息是两个<strong>键值对</strong>，容易猜到一个是<code>apikey</code>,一个是<code>text</code>,也就是你要发出去的消息，而请求的url由图灵官方提供，为<a href="http://www.tuling123.com/openapi/api">http://www.tuling123.com/openapi/api</a><br>这样思路就明了了，下面是代码实现。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="python通过requests实现"><a href="#python通过requests实现" class="headerlink" title="python通过requests实现"></a>python通过<code>requests</code>实现</h3><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs nix"><span class="hljs-built_in">import</span> requests <span class="hljs-comment">#导入库</span><br><span class="hljs-attr">s</span> = &#123;<br><span class="hljs-string">&quot;key&quot;</span>:<span class="hljs-string">&quot;your apikey&quot;</span>,<br>    <span class="hljs-string">&quot;info&quot;</span>:<span class="hljs-string">&quot;你多大了&quot;</span><br>&#125;<br><span class="hljs-attr">r</span> = requests.post(<span class="hljs-string">&quot;http://www.tuling123.com/openapi/api&quot;</span>,<span class="hljs-attr">data=s)#post请求</span><br>r.<span class="hljs-attr">encoding</span> = r.apparent_encoding<br>print(r.text)<br></code></pre></td></tr></table></figure><p>返回的<code>r.text</code>是<code>json</code>信息，进行简单的字符串提取就ok</p><h3 id="android通过Okhttp实现"><a href="#android通过Okhttp实现" class="headerlink" title="android通过Okhttp实现"></a>android通过<code>Okhttp</code>实现</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> void get<span class="hljs-constructor">Content(String <span class="hljs-params">s</span>)</span><br>&#123;<br><span class="hljs-keyword">new</span> <span class="hljs-constructor">Thread(()</span> -&gt; &#123;<span class="hljs-comment">//new thread</span><br><span class="hljs-keyword">try</span> &#123;<br>OkHttpClient client = <span class="hljs-keyword">new</span> <span class="hljs-constructor">OkHttpClient()</span>;<br>RequestBody body = <span class="hljs-keyword">new</span> FormBody.<span class="hljs-constructor">Builder()</span><br>.add(<span class="hljs-string">&quot;key&quot;</span>,key)<span class="hljs-comment">//key is your apikey</span><br>.add(<span class="hljs-string">&quot;info&quot;</span>,s)<br>.build<span class="hljs-literal">()</span>;<span class="hljs-comment">//request body</span><br>Request request = <span class="hljs-keyword">new</span> Request.<span class="hljs-constructor">Builder()</span><br>.url(<span class="hljs-string">&quot;http://www.tuling123.com/openapi/api&quot;</span>)<br>.post(body)<br>.build<span class="hljs-literal">()</span>;<br>Response response = client.<span class="hljs-keyword">new</span><span class="hljs-constructor">Call(<span class="hljs-params">request</span>)</span>.execute<span class="hljs-literal">()</span>;<br>String s1 = response.body<span class="hljs-literal">()</span>.<span class="hljs-built_in">string</span><span class="hljs-literal">()</span>;#get the content<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>d(<span class="hljs-string">&quot;s&quot;</span>,s1 );<span class="hljs-comment">//s1 is the resuests(json)</span><br>&#125;catch (Exception e)&#123;<br>e.print<span class="hljs-constructor">StackTrace()</span>;<br>&#125;<br>&#125;<br>).start<span class="hljs-literal">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>整个app的代码可参考<a href="https://github.com/hhhxiao/Chat">Chat</a></p>]]></content>
    
    
    <categories>
      
      <category>android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>android</tag>
      
      <tag>OKhttp</tag>
      
      <tag>python</tag>
      
      <tag>post</tag>
      
      <tag>requests</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>相量分析</title>
    <link href="/2018/05/09/%E7%9B%B8%E9%87%8F%E5%88%86%E6%9E%90/"/>
    <url>/2018/05/09/%E7%9B%B8%E9%87%8F%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>这篇讨论的是正弦电路下<strong>电阻，电容，电感</strong>在正弦稳态下的电流和电压的相位关系，主要思路还是<strong>激励和响应</strong></p><a id="more"></a><h2 id="电阻"><a href="#电阻" class="headerlink" title="电阻"></a>电阻</h2><p>设激励的电压为：$u=U_{m}sin(\omega t+\psi)$,对应的$\dot{U}=U\angle \psi$<br>根据经典的<strong>欧姆定律</strong>，流经电阻R的的电流$i_{R}$有：<br>$$<br>i_{R} = \frac{u}{R} = \frac{U_{m}}{R} sin(\omega t+\psi)<br>$$<br>$i_{R}$对应的$\dot{I} = \frac{U_{m}}{R} \angle \psi$,于是在复平面中$\dot{U}$和$\dot{I}$是同方向的相量（辐角均为$\psi$）,模的绝对值之比为定值电阻的阻值。</p><h2 id="电感"><a href="#电感" class="headerlink" title="电感"></a>电感</h2><p>根据电感的性质$U=L\frac{di}{dt}$：用电流源作为激励是更好的选择：$i=I_{m}sin(\omega t+\psi)$,对应的$\dot{I}=I\angle \psi$,此时的电压u:<br>$$<br>u_{L}=L\frac{di}{dt}=L\omega I_{m}cos(\omega  t+\psi)=L\omega I_{m}sin(\omega t+\psi+\frac{\pi}{2})<br>$$<br>对应的$\dot{U} = L\omega I\angle{(\psi+\frac{\pi}{2})}$<br>于是：($\angle{\frac{\pi}{2}}=0+1*j = j$)<br>$$<br>\frac{\dot{U}}{\dot{I}}=\frac{L\omega I\angle{(\psi+\frac{\pi}{2}})}{I\angle \psi}=\omega L\angle{\frac{\pi}{2}}=j\omega L<br>$$<br>可见在复平面内电感的电压相量超前电流相量$\frac{\pi}{2}$，其模的比值为$L\omega$.</p><h2 id="电容"><a href="#电容" class="headerlink" title="电容"></a>电容</h2><p>根据电容的性质$iC\frac{du}{dt}$：用电压源作为激励是更好的选择：$u=U_{m}sin(\omega t+\psi)$,对应的$\dot{U}=U\angle \psi$，此时的电流i:<br>$$<br>i_{C}=C\frac{du}{dt}=C\omega U_{m}cos(\omega t+\psi)=C\omega U_{m}sin(\omega t+\psi+\frac{\pi}{2})<br>$$<br>对应的$\dot{I} = C\omega U\angle{(\psi+\frac{\pi}{2})}$<br>于是：<br>$$<br>\frac{\dot{U}}{\dot{I}}=\frac{U\angle \psi}{C\omega U\angle{(\psi+\frac{\pi}{2})}}=\frac{1}{\omega C}\angle{-\frac{\pi}{2}}=\frac{1}{j\omega C}<br>$$<br>可见在复平面内电容的电压相量滞后电流相量$\frac{\pi}{2}$，其模的比值为$frac{1}{\omega L}$.</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>上述计算是正弦稳态电路分析的基础，理解了才在后面的学习中更加轻松。。(个人原因没图片展示)</p>]]></content>
    
    
    <categories>
      
      <category>电路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>电路分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正弦稳态1——复数</title>
    <link href="/2018/05/07/%E6%AD%A3%E5%BC%A6%E7%A8%B3%E6%80%811%E2%80%94%E2%80%94%E5%A4%8D%E6%95%B0/"/>
    <url>/2018/05/07/%E6%AD%A3%E5%BC%A6%E7%A8%B3%E6%80%811%E2%80%94%E2%80%94%E5%A4%8D%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="复数的表示"><a href="#复数的表示" class="headerlink" title="复数的表示"></a>复数的表示</h2><p>记$j = \sqrt{-1}$是复数的基本单位，一个一般的复数记为：</p><a id="more"></a><blockquote><p>直角坐标：$A = a+jb$<br>指数式：$A  =\gamma e^{j\psi}$<br>三角式：$A = \gamma(cos{\psi}+jsin{\psi})$</p></blockquote><p>三种形式可以互换：</p><blockquote><p>$\gamma = \sqrt{a^{2}+b^{2}}$<br>$a = \gamma cos{\psi}$<br>$b = \gamma sin{\psi}$</p></blockquote><p>$\psi$称之为复数的<strong>辐角</strong>$\gamma$称之为复数的<strong>模</strong></p><p>而在电路分析里面复数$A$记为：<br>$$ A=\gamma\angle\psi $$</p><h2 id="用复数表示正弦函数"><a href="#用复数表示正弦函数" class="headerlink" title="用复数表示正弦函数"></a>用复数表示正弦函数</h2><p>对于正弦函数$u = U_{m}sin(\omega t+\psi_{u})$用复数表示为：<br>$$u = U_{m}sin(\omega t+\psi_{u})$$<br>$$=Im[U_{m}e^{j(\omega t+\psi_{u})}]=Im[\sqrt{2}U\angle{\psi_{u}}e^{j\omega t}]$$<br>而在电路分析中常用<br>$$\dot{U} =U\angle{\psi_{u}} $$<br>来表示正弦函数$u = U_{m}sin(\omega t+\psi_{u})$,其中$U=\frac{\sqrt{2}U_{m}}{2}$,$\dot{U}$称为$u$的<strong>相量</strong><br>这样就把复数和正弦函数联系起来了。</p>]]></content>
    
    
    <categories>
      
      <category>电路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>电路分析</tag>
      
      <tag>复数</tag>
      
      <tag>正弦稳态</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>android 的广播</title>
    <link href="/2018/05/01/android-%E7%9A%84%E5%B9%BF%E6%92%AD/"/>
    <url>/2018/05/01/android-%E7%9A%84%E5%B9%BF%E6%92%AD/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>安卓的广播机制是一套十分灵活的<strong>消息/信号</strong>的<strong>发送(send)/接收（receive）</strong>机制，系统或者应用发出的广播（消息）可以覆盖几乎整个Android,因此广播机制是跨应用的，全局的。</p><a id="more"></a><h2 id="自定义个广播接收器-custom-BroadcastReceiver"><a href="#自定义个广播接收器-custom-BroadcastReceiver" class="headerlink" title="自定义个广播接收器(custom BroadcastReceiver)"></a>自定义个广播接收器(custom BroadcastReceiver)</h2><p>广播接收器的实质是一个监听器(接收到广播时执行相应的动作)，创建该监听器只需创建一个继承自<code>BroadcastReceiver</code>的类，并重写(override)其中的<code>onReceive</code>方法：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">package</span> com.notice.agno3.receiver;<br><br><span class="hljs-keyword">import</span> android.content.<span class="hljs-type">BroadcastReceiver</span>;<br><span class="hljs-keyword">import</span> android.content.<span class="hljs-type">Context</span>;<br><span class="hljs-keyword">import</span> android.content.<span class="hljs-type">Intent</span>;<br><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyReceiver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BroadcastReceiver</span> </span>&#123;<br><span class="hljs-meta">@Override</span><br>public void onReceive(<span class="hljs-type">Context</span> context, <span class="hljs-type">Intent</span> intent) &#123;<br><span class="hljs-comment">//<span class="hljs-doctag">TODO:</span>write what you want to do when receive a broadcast,such as a toast:</span><br><span class="hljs-type">Toast</span>.makeText(context,<span class="hljs-string">&quot;network changed&quot;</span> ,<span class="hljs-type">Toast</span>.<span class="hljs-type">LENGTH_SHORT</span> ).show();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就写好了自定义的receiver ，方法体里面写在收到广播的时候要干的事情。</p><h2 id="使用自定义的广播接收器-use-your-customized-BroadcastReceiver"><a href="#使用自定义的广播接收器-use-your-customized-BroadcastReceiver" class="headerlink" title="使用自定义的广播接收器(use your customized BroadcastReceiver)"></a>使用自定义的广播接收器(use your customized BroadcastReceiver)</h2><p>  要有广播才能使用广播接收器，目前先使用系统自带的广播(后面有自定义广播)，例如：在手机的网络情况发生变化时系统会发一条值为<code>android.net.conn.CONNECTIVITY_CHANGE</code>的广播。<br>  使用接收器的过程可以称为注册，注册分为<strong>动态注册</strong>和<strong>静态注册</strong>两种。</p><h3 id="动态注册"><a href="#动态注册" class="headerlink" title="动态注册"></a>动态注册</h3><p>  首先利用<code>IntentFilter（意图筛选器）</code>把值为<code>android.net.conn.CONNECTIVITY_CHANGE</code>的广播筛选出来;然后利用<code>registerReceiver</code>方法进行注册；最后不要忘记在<code>onDestroy()</code>方法中取消注册：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">//MainActivity.java</span><br><span class="hljs-keyword">package</span> com.notice.agno3.receiver;<br><span class="hljs-keyword">import</span> android.content.<span class="hljs-type">IntentFilter</span>;<br><span class="hljs-keyword">import</span> android.support.v7.app.<span class="hljs-type">AppCompatActivity</span>;<br><span class="hljs-keyword">import</span> android.os.<span class="hljs-type">Bundle</span>;<br><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>&#123;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">IntentFilter</span> intentFilter;<br><span class="hljs-keyword">private</span>  <span class="hljs-type">MyReceiver</span> myReceiver;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> void onCreate(<span class="hljs-type">Bundle</span> savedInstanceState) &#123;<br><span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>setContentView(<span class="hljs-type">R</span>.layout.activity_main);<br>intentFilter = <span class="hljs-keyword">new</span> <span class="hljs-type">IntentFilter</span>();<br><span class="hljs-comment">//set the filter</span><br>intentFilter.addAction(<span class="hljs-string">&quot;android.net.conn.CONNECTIVITY_CHANGE&quot;</span>);<br><span class="hljs-comment">//register the broadcast</span><br>myReceiver = <span class="hljs-keyword">new</span> <span class="hljs-type">MyReceiver</span>();<br>registerReceiver(myReceiver, intentFilter);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> void onDestroy() &#123;<br><span class="hljs-keyword">super</span>.onDestroy();<br>unregisterReceiver(myReceiver);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样在运行app的时候，只要改变网络状态，app就会弹出一条toast显示“network changed”.但如果想在不运行这个app的时候也能进行监听，这就要靠<strong>静态注册</strong>了。</p><h3 id="静态注册"><a href="#静态注册" class="headerlink" title="静态注册"></a>静态注册</h3><p>静态注册的思路和动态注册思路一样，只不过不在java代码中写,而是在<code>AndroidManifest.xml</code>进行注册，在<code>&lt;application&gt;&lt;application/&gt;</code>内加入：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">receiver</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.MyReceiver&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:enabled</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:exported</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">action</span>  </span><br><span class="hljs-tag">                    <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.net.conn.CONNECTIVITY_CHANGE&quot;</span></span><br><span class="hljs-tag">                    <span class="hljs-attr">tools:ignore</span>=<span class="hljs-string">&quot;BatteryLife&quot;</span> /&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">receiver</span>&gt;</span><br></code></pre></td></tr></table></figure><p>主要看<code>&lt;intent-filter&gt;</code>标签，同样起到了过滤效果。</p><h2 id="自定义广播"><a href="#自定义广播" class="headerlink" title="自定义广播"></a>自定义广播</h2><p>自定义广播通过<code>Intent</code>进行发送，应该还是好理解的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Intent intent = <span class="hljs-keyword">new</span> Intent(<span class="hljs-string">&quot;com.agno3.MY_BROADCAST&quot;</span>);<br>sendBroadcast(intent);<br></code></pre></td></tr></table></figure><p>把它放在button的监听事件中（或其他触发方式）,点击按钮就能发送自定义的广播了，同样可以用自定义的接收器进行接收：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//custom receiver</span><br><span class="hljs-keyword">package</span> com.notice.agno3.receiver;<br><br><span class="hljs-keyword">import</span> android.content.BroadcastReceiver;<br><span class="hljs-keyword">import</span> android.content.Context;<br><span class="hljs-keyword">import</span> android.content.Intent;<br><span class="hljs-keyword">import</span> android.widget.Toast;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyReceiver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BroadcastReceiver</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onReceive</span><span class="hljs-params">(Context context, Intent intent)</span> </span>&#123;<br>        <span class="hljs-comment">//<span class="hljs-doctag">TODO:</span>write what you want to do when receive a broadcast</span><br>        Toast.makeText(context,<span class="hljs-string">&quot;button is clicked it has sent a broad cast&quot;</span> ,Toast.LENGTH_SHORT ).show();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>然后是MainActivity.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//MainActivity.java</span><br><span class="hljs-keyword">package</span> com.notice.agno3.receiver;<br><br><span class="hljs-keyword">import</span> android.content.Intent;<br><span class="hljs-keyword">import</span> android.content.IntentFilter;<br><span class="hljs-keyword">import</span> android.support.v7.app.AppCompatActivity;<br><span class="hljs-keyword">import</span> android.os.Bundle;<br><span class="hljs-keyword">import</span> android.view.View;<br><span class="hljs-keyword">import</span> android.widget.Button;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> IntentFilter intentFilter;<br>    <span class="hljs-keyword">private</span>  MyReceiver myReceiver;<br>    <span class="hljs-keyword">private</span> Button button;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_main);<br>        <span class="hljs-comment">//button</span><br>        button = findViewById(R.id.button);<br>        button.setOnClickListener(<span class="hljs-keyword">new</span> View.OnClickListener() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View v)</span> </span>&#123;<br>                <span class="hljs-comment">//send receiver</span><br>                Intent intent = <span class="hljs-keyword">new</span> Intent(<span class="hljs-string">&quot;com.agno3.MY_RECEIVER&quot;</span>);<br>                sendBroadcast(intent);<br>            &#125;<br>        &#125;);<br>        <span class="hljs-comment">//set the filter</span><br>        intentFilter = <span class="hljs-keyword">new</span> IntentFilter();<br>        intentFilter.addAction(<span class="hljs-string">&quot;com.agno3.MY_RECEIVER&quot;</span>);<br>        myReceiver = <span class="hljs-keyword">new</span> MyReceiver();<br>        <span class="hljs-comment">//register</span><br>        registerReceiver(myReceiver, intentFilter);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDestroy</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onDestroy();<br>        unregisterReceiver(myReceiver);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 点击屏幕上按钮就会有toast:”button is clicked it has sent a broad cast”这样就完成了一次send + receive 的完整操作。注意这里的广播其他应用也是可以接收的，要发送其他应用无法接收的需要本底广播，详见下篇。</p>]]></content>
    
    
    <categories>
      
      <category>android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>BroadcastReceiver</tag>
      
      <tag>广播接收器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小记</title>
    <link href="/2018/04/26/%E5%B0%8F%E8%AE%B0/"/>
    <url>/2018/04/26/%E5%B0%8F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="小记——博客开篇"><a href="#小记——博客开篇" class="headerlink" title="小记——博客开篇"></a>小记——博客开篇</h2><p>这是博客的第一篇文章，工科生文笔着实不好。望见谅。<br>这个小博客仅供自己记录和学习使用，故没有增加评论和阅读次数统计功能。你若看见了便是缘分，能从中学习知识甚至找到共鸣便是我的荣幸。</p><a id="more"></a><p>我是机械设计制造及自动化专业的学生，在写这篇文章的时候也是我得知自己转专业失败的时候，内心比较复杂，但因为此也正好有话可说。</p><p>我热衷于计算机，建立这个小博客也是自己计算机之路的一个小步骤，当然转去计算机也是。当我一块砖一块砖堆砌自己的梦想的时候，最重要的一块我却未能成功搬起来，反而被它砸到了脚。在刚刚得知这个消息的时候，我的内心是崩溃的，因为我回忆自己的面试以及考试是多么顺利，然而最后结果是<strong>我没有过</strong>。我无法理解，自己到底做错了什么，内心一度郁闷。<br>  我比其他人投入的多太多，但失败时我最终没有发泄出来，我没有当愤青去抱怨这个世界的不公，而是选择平静地接受了这个事实，在旁人问起“你这么喜欢计算机为什么没有过啊？”的时候，我无法回答，只能陈述事实，没有过就是没过。不过我只能在机械这条路上走下去，从另外一个角度去探寻真理，去追寻深处所谓的“梦想”吗?</p><p>现实总是如此残酷，我也只能默默地忍受这一事实，失败就是失败，无法狡辩。然而可怕的不是失败，而是缺少面对失败的勇气。因此，在屋漏偏逢连夜雨的时候，我还是要把博客更新下去，计算机这条路也不会因此停下，共勉。</p>]]></content>
    
    
    <categories>
      
      <category>小记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BlogText</title>
    <link href="/2018/04/25/BlogText/"/>
    <url>/2018/04/25/BlogText/</url>
    
    <content type="html"><![CDATA[<p>一篇博客测试也是markdown语法记录</p><p><code># title 1</code></p><h1 id="title-1"><a href="#title-1" class="headerlink" title="title 1"></a>title 1</h1><p><code>## title 2</code></p><h2 id="title-2"><a href="#title-2" class="headerlink" title="title 2"></a>title 2</h2><p><code>### title 3</code></p><h3 id="title-3"><a href="#title-3" class="headerlink" title="title 3"></a>title 3</h3><p><code>#### title 4</code></p><h4 id="title-4"><a href="#title-4" class="headerlink" title="title 4"></a>title 4</h4><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">other title1<br>==<br></code></pre></td></tr></table></figure><h1 id="other-title1"><a href="#other-title1" class="headerlink" title="other title1"></a>other title1</h1><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">other title2<br>--<br></code></pre></td></tr></table></figure><h2 id="other-title2"><a href="#other-title2" class="headerlink" title="other title2"></a>other title2</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash"> 1. I love my university</span><br><span class="hljs-meta">&gt;</span><span class="bash"> 2. I like UESTC</span><br><br><span class="hljs-meta">&gt;</span><span class="bash">frist</span><br><span class="hljs-meta">&gt;</span><span class="bash">&gt;secont</span><br><span class="hljs-meta">&gt;</span><span class="bash">&gt;&gt; third</span><br></code></pre></td></tr></table></figure><blockquote><ol><li>I love my university</li><li>I like UESTC</li></ol></blockquote><blockquote><p>frist</p><blockquote><p>secont</p><blockquote><p>third</p></blockquote></blockquote></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">+</span> dede<br><span class="hljs-bullet">+</span> dedef<br><span class="hljs-bullet">+</span> dewfwfwe<br></code></pre></td></tr></table></figure><ul><li>dede</li><li>dedef</li><li>dewfwfwe</li></ul><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">- </span>list<br><span class="hljs-bullet">- </span>list<br><span class="hljs-bullet">- </span>list<br></code></pre></td></tr></table></figure><ul><li>list</li><li>list</li><li>list</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>. list<span class="hljs-number">1</span><br><span class="hljs-attribute">2</span>. list<span class="hljs-number">2</span><br><span class="hljs-attribute">3</span>. list<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><ol><li>list1</li><li>list2</li><li>list3</li></ol><p><code>**粗体（blod）**</code></p><p><strong>粗体（blod）</strong></p><p><code>*斜体*</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>斜体</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//code</span><br>  <span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br></code></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-string">[AgNO3&#x27;Blog]</span>(http:<span class="hljs-comment">//hhhxiao.github.io&quot;)</span><br></code></pre></td></tr></table></figure><p> <a href="http://hhhxiao.github.io"/">AgNO3’Blog</a></p><p> <code>![](https://ss1.baidu.com/9vo3dSag_xI4khGko9WTAnF6hhy/image/h%3D300/sign=f4d8ab6c02f41bd5c553eef461db81a0/f9198618367adab4c32b570487d4b31c8601e4fa.jpg)</code><br><img src="https://ss1.baidu.com/9vo3dSag_xI4khGko9WTAnF6hhy/image/h%3D300/sign=f4d8ab6c02f41bd5c553eef461db81a0/f9198618367adab4c32b570487d4b31c8601e4fa.jpg"></p><p><code>数学公式$sqrt(a-b^2)$</code></p><p>数学公式$sqrt(a-b^2)$</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br>\int_a^b f(x)dx<br><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br></code></pre></td></tr></table></figure><p>$$<br>\int_a^b f(x)dx<br>$$</p><p><code>****</code>(分割线)</p><hr><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">name |<span class="hljs-string"> age</span>|<br>---- |<span class="hljs-string"> ---</span>|<br>LearnShare |<span class="hljs-string"> 12</span><br><span class="hljs-string">Mike </span>|<span class="hljs-string">  32</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>name</th><th>age</th></tr></thead><tbody><tr><td>LearnShare</td><td>12</td></tr><tr><td>Mike</td><td>32</td></tr></tbody></table><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string"> left </span>|<span class="hljs-string"> center </span>|<span class="hljs-string"> right </span>|<br>|<span class="hljs-string"> :--- </span>|<span class="hljs-string"> :----: </span>|<span class="hljs-string"> ----: </span>|<br>|<span class="hljs-string"> aaaa </span>|<span class="hljs-string"> bbbbbb </span>|<span class="hljs-string"> ccccc </span>|<br>|<span class="hljs-string"> a    </span>|<span class="hljs-string"> b      </span>|<span class="hljs-string"> c     </span>|<br></code></pre></td></tr></table></figure><table><thead><tr><th align="left">left</th><th align="center">center</th><th align="right">right</th></tr></thead><tbody><tr><td align="left">aaaa</td><td align="center">bbbbbb</td><td align="right">ccccc</td></tr><tr><td align="left">a</td><td align="center">b</td><td align="right">c</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>others</category>
      
    </categories>
    
    
    <tags>
      
      <tag>markdown</tag>
      
      <tag>BlogText</tag>
      
      <tag>data</tag>
      
      <tag>mathjax</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
